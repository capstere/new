--- a/New folder/Modules/RuleEngine.ps1
+++ b/New folder/Modules/RuleEngine.ps1
@@ -1,1174 +1,1231 @@
-# RuleEngine.ps1 (Windows PowerShell 5.1)
-# Shadow-mode RuleEngine + RuleBank (CSV-driven)
-# - Does NOT change legacy report logic unless explicitly wired
-# - Produces per-row: ObservedCall, ExpectedCall, Deviation, ErrorCode/RetestPolicy
-# - Writes RuleEngine_Debug worksheet (shadow)
-
-function Import-RuleCsv {
-    param([Parameter(Mandatory)][string]$Path)
-    if (-not (Test-Path -LiteralPath $Path)) { return @() }
-
-    $delim = ','
-    try { $delim = Get-CsvDelimiter -Path $Path } catch {}
-
-    try {
-        $lines = Get-Content -LiteralPath $Path -ErrorAction Stop
-        if (-not $lines -or $lines.Count -lt 1) { return @() }
-        return @(ConvertFrom-Csv -InputObject ($lines -join "`n") -Delimiter $delim)
-    } catch {
-        try { return @(Import-Csv -LiteralPath $Path -Delimiter $delim) } catch { return @() }
-    }
-}
-
-function Load-RuleBank {
-    param([Parameter(Mandatory)][string]$RuleBankDir)
-
-    $rb = [ordered]@{
-        Dir = $RuleBankDir
-        ResultCallPatterns = @()
-        SampleExpectationRules = @()
-        ErrorCodes = @()
-        MissingSamplesConfig = @()
-        SampleIdMarkers = @()
-        ParityCheckConfig = @()
-        SampleNumberRules = @()
-    }
-
-    if (-not (Test-Path -LiteralPath $RuleBankDir)) { return [pscustomobject]$rb }
-
-    $map = @{
-        ResultCallPatterns      = '01_ResultCallPatterns.csv'
-        SampleExpectationRules  = '02_SampleExpectationRules.csv'
-        ErrorCodes              = '03_ErrorCodes.csv'
-        MissingSamplesConfig    = '04_MissingSamplesConfig.csv'
-        SampleIdMarkers         = '05_SampleIdMarkers.csv'
-        ParityCheckConfig       = '06_ParityCheckConfig.csv'
-        SampleNumberRules       = '07_SampleNumberRules.csv'
-    }
-
-    foreach ($k in $map.Keys) {
-        $p = Join-Path $RuleBankDir $map[$k]
-        $rb[$k] = Import-RuleCsv -Path $p
-    }
-
-    # Priority sort where applicable
-    try { $rb.ResultCallPatterns = @($rb.ResultCallPatterns | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
-    try { $rb.SampleExpectationRules = @($rb.SampleExpectationRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
-    try { $rb.ParityCheckConfig = @($rb.ParityCheckConfig | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
-    try { $rb.SampleIdMarkers = @($rb.SampleIdMarkers | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
-    try { $rb.SampleNumberRules = @($rb.SampleNumberRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
-
-    return [pscustomobject]$rb
-}
-
-function Get-RowField {
-    param(
-        [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][string]$FieldName
-    )
-    try {
-        $p = $Row.PSObject.Properties[$FieldName]
-        if ($p -and $null -ne $p.Value) { return $p.Value }
-    } catch {}
-    return ''
-}
-
-function Test-RuleEnabled {
-    param([Parameter(Mandatory)][object]$Rule)
-    $en = (Get-RowField -Row $Rule -FieldName 'Enabled')
-    if ($en -eq $null) { return $true }
-    $s = ($en + '').Trim().ToUpperInvariant()
-    if (-not $s) { return $true }
-    return ($s -in @('TRUE','1','YES','Y'))
-}
-
-function Test-AssayMatch {
-    <#
-      Supports:
-      - empty / '*' => match all
-      - wildcard patterns (contains '*' or '?') via -like
-      - otherwise case-insensitive equals
-    #>
-    param(
-        [Parameter(Mandatory)][string]$RuleAssay,
-        [Parameter(Mandatory)][string]$RowAssay
-    )
-    $ra = ($RuleAssay + '').Trim()
-    if (-not $ra -or $ra -eq '*') { return $true }
-
-    $row = ($RowAssay + '').Trim()
-    if ($ra -like '*[*?]*') {
-        return ($row -like $ra)
-    }
-    return ($ra -ieq $row)
-}
-
-function Match-Text {
-    param(
-        [Parameter(Mandatory)][string]$Text,
-        [Parameter(Mandatory)][string]$Pattern,
-        [Parameter(Mandatory)][string]$MatchType
-    )
-
-    $t = ($Text + '')
-    $p = ($Pattern + '')
-    $m = ($MatchType + '').Trim().ToUpperInvariant()
-    if (-not $m) { $m = 'CONTAINS' }
-
-    try {
-        switch ($m) {
-            'REGEX'  { return [regex]::IsMatch($t, $p, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) }
-            'EQUALS' { return (($t.Trim()).ToUpperInvariant() -eq ($p.Trim()).ToUpperInvariant()) }
-            'PREFIX' {
-                $tt = ($t.Trim()).ToUpperInvariant()
-                $pp = ($p.Trim()).ToUpperInvariant()
-                if (-not $pp) { return $true }
-                return ($tt.Length -ge $pp.Length -and $tt.Substring(0, $pp.Length) -eq $pp)
-            }
-            'SUFFIX' {
-                $tt = ($t.Trim()).ToUpperInvariant()
-                $pp = ($p.Trim()).ToUpperInvariant()
-                if (-not $pp) { return $true }
-                return ($tt.Length -ge $pp.Length -and $tt.Substring($tt.Length - $pp.Length) -eq $pp)
-            }
-            default {
-                return (($t.ToUpperInvariant()).Contains($p.ToUpperInvariant()))
-            }
-        }
-    } catch {
-        return $false
-    }
-}
-
-function Get-ObservedCallDetailed {
-    param(
-        [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][object[]]$Patterns
-    )
-
-    $status = (Get-RowField -Row $Row -FieldName 'Status')
-    $errTxt = (Get-RowField -Row $Row -FieldName 'Error')
-    $testResult = (Get-RowField -Row $Row -FieldName 'Test Result')
-    $assay = (Get-RowField -Row $Row -FieldName 'Assay')
-
-    if (($errTxt + '').Trim()) {
-        return [pscustomobject]@{ Call='ERROR'; Reason='Error column populated' }
-    }
-    $st = ($status + '').Trim()
-    if ($st -and ($st -ine 'Done')) {
-        return [pscustomobject]@{ Call='ERROR'; Reason=("Status=" + $st) }
-    }
-
-    $tr = ($testResult + '').Trim()
-    if (-not $tr) { return [pscustomobject]@{ Call='UNKNOWN'; Reason='Blank Test Result' } }
-
-    # MTB-family override: treat MTB DETECTED/TRACE DETECTED as POS even if RIF contains NOT DETECTED/INDETERMINATE.
-    # Prevent classic false INDET/NEG due to substring collisions.
-    $ass = ($assay + '')
-    if ($ass -match 'MTB') {
-        if ($tr -match '(?i)\bMTB\s+TRACE\s+DETECTED\b') {
-            return [pscustomobject]@{ Call='POS'; Reason='MTB Trace detected (override)' }
-        }
-        if ($tr -match '(?i)\bMTB\s+DETECTED\b') {
-            return [pscustomobject]@{ Call='POS'; Reason='MTB detected (override)' }
-        }
-        if ($tr -match '(?i)\bMTB\s+NOT\s+DETECTED\b') {
-            return [pscustomobject]@{ Call='NEG'; Reason='MTB not detected (override)' }
-        }
-    }
-
-    foreach ($r in $Patterns) {
-        if (-not (Test-RuleEnabled $r)) { continue }
-        $ruleAssay = (Get-RowField -Row $r -FieldName 'Assay')
-        if (-not (Test-AssayMatch -RuleAssay $ruleAssay -RowAssay $assay)) { continue }
-
-        $pat  = (Get-RowField -Row $r -FieldName 'Pattern')
-        if (-not ($pat + '').Trim()) { continue }
-        $mt   = (Get-RowField -Row $r -FieldName 'MatchType')
-
-        if (Match-Text -Text $tr -Pattern $pat -MatchType $mt) {
-            $call = ((Get-RowField -Row $r -FieldName 'Call') + '').Trim().ToUpperInvariant()
-            if ($call) {
-                $note = (Get-RowField -Row $r -FieldName 'Note')
-                $why = if (($note + '').Trim()) { $note } else { ("Matched " + $mt + ": " + $pat) }
-                return [pscustomobject]@{ Call=$call; Reason=$why }
-            }
-        }
-    }
-
-    return [pscustomobject]@{ Call='UNKNOWN'; Reason='No pattern matched' }
-}
-
-function Get-ExpectedCallDetailed {
-    param(
-        [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][object[]]$Rules
-    )
-
-    $sampleId = (Get-RowField -Row $Row -FieldName 'Sample ID')
-    $assay    = (Get-RowField -Row $Row -FieldName 'Assay')
-    $sid = ($sampleId + '').Trim()
-    if (-not $sid) { return [pscustomobject]@{ Call=''; Reason='Blank Sample ID' } }
-
-    foreach ($r in $Rules) {
-        if (-not (Test-RuleEnabled $r)) { continue }
-        $ruleAssay = (Get-RowField -Row $r -FieldName 'Assay')
-        if (-not (Test-AssayMatch -RuleAssay $ruleAssay -RowAssay $assay)) { continue }
-
-        $mtype = (Get-RowField -Row $r -FieldName 'SampleIdMatchType')
-        $pat   = (Get-RowField -Row $r -FieldName 'SampleIdPattern')
-        if (-not ($pat + '').Trim()) { continue }
-
-        if (Match-Text -Text $sid -Pattern $pat -MatchType $mtype) {
-            $call = ((Get-RowField -Row $r -FieldName 'Expected') + '').Trim().ToUpperInvariant()
-            if ($call) {
-                $note = (Get-RowField -Row $r -FieldName 'Note')
-                $why = if (($note + '').Trim()) { $note } else { ("Matched " + $mtype + ": " + $pat) }
-                return [pscustomobject]@{ Call=$call; Reason=$why }
-            }
-        }
-    }
-
-    return [pscustomobject]@{ Call=''; Reason='No expectation rule matched' }
-}
-
-function Get-ExpectedTestTypeDerived {
-    param([Parameter(Mandatory)][string]$SampleId)
-
-    $parts = $SampleId.Split('_')
-    if ($parts.Count -ge 3) {
-        $tc = $parts[2]
-        switch -Regex ($tc) {
-            '^0$' { return 'Negative Control 1' }
-            '^1$' { return 'Positive Control 1' }
-            '^2$' { return 'Positive Control 2' }
-            '^3$' { return 'Positive Control 3' }
-            '^4$' { return 'Positive Control 4' }
-            '^5$' { return 'Positive Control 5' }
-            default { }
-        }
-    }
-    return 'Specimen'
-}
-
-function Build-ErrorCodeLookup {
-    param([Parameter(Mandatory)][object[]]$ErrorCodes)
-
-    # Supports:
-    # - numeric codes (4-5 digits)
-    # - multiple defaults via '####' (we choose based on content when possible)
-    # - "blank code" rows (used for derived flags like pressure) exposed as NamedBlanks
-    $lut = @{
-        Codes = @{}
-        Defaults = New-Object System.Collections.Generic.List[object]
-        NamedBlanks = New-Object System.Collections.Generic.List[object]
-    }
-
-    foreach ($r in $ErrorCodes) {
-        $code = ((Get-RowField -Row $r -FieldName 'ErrorCode') + '').Trim()
-        $name = (Get-RowField -Row $r -FieldName 'Name')
-        $ret  = (Get-RowField -Row $r -FieldName 'GeneratesRetest')
-
-        if ($code -eq '####') {
-            $lut.Defaults.Add([pscustomobject]@{ ErrorCode='####'; Name=$name; GeneratesRetest=$ret })
-            continue
-        }
-
-        if (-not $code) {
-            if (($name + '').Trim()) { $lut.NamedBlanks.Add([pscustomobject]@{ ErrorCode=''; Name=$name; GeneratesRetest=$ret }) }
-            continue
-        }
-
-        if ($code -match '^\d{4,5}$') {
-            $lut.Codes[$code] = [pscustomobject]@{ ErrorCode=$code; Name=$name; GeneratesRetest=$ret }
-        }
-    }
-
-    return $lut
-}
-
-function Get-ErrorInfo {
-    param(
-        [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][hashtable]$ErrorLut,
-        [Parameter(Mandatory)][string]$DelamPattern
-    )
-
-    $errTxt = (Get-RowField -Row $Row -FieldName 'Error')
-    $mpTxt  = (Get-RowField -Row $Row -FieldName 'Max Pressure (PSI)')
-
-    $code = ''
-    $hasErr = (($errTxt + '').Trim().Length -gt 0)
-
-    if ($hasErr) {
-        if (($errTxt + '') -match '(\d{4,5})') { $code = $Matches[1] }
-    }
-
-    $name = ''
-    $retest = ''
-
-    if ($hasErr) {
-        if ($code -and $ErrorLut.Codes.ContainsKey($code)) {
-            $name   = $ErrorLut.Codes[$code].Name
-            $retest = $ErrorLut.Codes[$code].GeneratesRetest
-        } else {
-            # Choose default:
-            # 1) if error text indicates delamination and a "Delamination" default exists -> use that
-            # 2) else use the last default (typically "Other error codes")
-            $picked = $null
-            try {
-                foreach ($d in $ErrorLut.Defaults) {
-                    if (($d.Name + '') -match '(?i)Delamination' -and ($errTxt + '') -match $DelamPattern) {
-                        $picked = $d; break
-                    }
-                }
-                if (-not $picked -and $ErrorLut.Defaults.Count -gt 0) { $picked = $ErrorLut.Defaults[$ErrorLut.Defaults.Count - 1] }
-            } catch {}
-            if ($picked) {
-                $name   = $picked.Name
-                $retest = $picked.GeneratesRetest
-            }
-        }
-    }
-
-    $pressure = $null
-    try {
-        if (($mpTxt + '').Trim()) { $pressure = [double]($mpTxt + '') }
-    } catch {}
-
-    $pressureFlag = $false
-    if ($pressure -ne $null -and $pressure -gt 90) { $pressureFlag = $true }
-
-    # If pressure flag and there is a named blank describing it, surface the name
-    if ($pressureFlag -and -not $name) {
-        try {
-            foreach ($b in $ErrorLut.NamedBlanks) {
-                if (($b.Name + '') -match '(?i)Max\s+Pressure') {
-                    $name = $b.Name
-                    $retest = $b.GeneratesRetest
-                    break
-                }
-            }
-        } catch {}
-    }
-
-    return [pscustomobject]@{
-        ErrorCode       = $code
-        ErrorName       = $name
-        GeneratesRetest = $retest
-        MaxPressure     = $pressure
-        PressureFlag    = $pressureFlag
-    }
-}
-
-function Classify-Deviation {
-    param(
-        [AllowEmptyString()][string]$Expected,
-        [AllowEmptyString()][string]$Observed
-    )
-    $e = ($Expected + '').Trim().ToUpperInvariant()
-    $o = ($Observed + '').Trim().ToUpperInvariant()
-
-    if (-not $e) { return 'UNKNOWN' }
-    if ($o -eq 'ERROR') { return 'ERROR' }
-    if ($o -eq 'UNKNOWN' -or -not $o) { return 'UNKNOWN' }
-    if ($e -eq $o) { return 'OK' }
-    if ($e -eq 'POS' -and $o -eq 'NEG') { return 'FN' }
-    if ($e -eq 'NEG' -and $o -eq 'POS') { return 'FP' }
-    return 'MISMATCH'
-}
-
-function Split-CsvLineQuoted {
-    param(
-        [Parameter(Mandatory)][string]$Line,
-        [Parameter(Mandatory)][string]$Delimiter
-    )
-    $d = [regex]::Escape($Delimiter)
-    $rx = $d + '(?=(?:(?:[^"]*"){2})*[^"]*$)'
-    return [regex]::Split($Line, $rx)
-}
-
-function Get-HeaderFromTestSummaryFile {
-    param([Parameter(Mandatory)][string]$CsvPath)
-
-    if (-not (Test-Path -LiteralPath $CsvPath)) { return @() }
-
-    $delim = ','
-    try { $delim = Get-CsvDelimiter -Path $CsvPath } catch {}
-
-    $lines = @()
-    try { $lines = Get-Content -LiteralPath $CsvPath -ErrorAction Stop } catch { return @() }
-
-    # Test Summary: header is line 8 (index 7)
-    if (-not $lines -or $lines.Count -lt 8) { return @() }
-    $hdrLine = $lines[7]
-    if (-not $hdrLine) { return @() }
-
-    $headers = Split-CsvLineQuoted -Line $hdrLine -Delimiter $delim
-    $headers = @($headers | ForEach-Object { (($_ + '') -replace '^"|"$','').Trim() })
-    return $headers
-}
-
-function Convert-FieldRowsToObjects {
-    param(
-        [Parameter(Mandatory)][object[]]$FieldRows,
-        [Parameter(Mandatory)][string[]]$Headers
-    )
-
-    $out = New-Object System.Collections.Generic.List[object]
-
-    foreach ($r in $FieldRows) {
-        if ($null -eq $r) { continue }
-        $arr = $r
-        if ($arr -isnot [object[]]) { continue }
-
-        $o = [ordered]@{}
-        $max = [Math]::Min($Headers.Count, $arr.Count)
-        for ($i=0; $i -lt $max; $i++) {
-            $h = $Headers[$i]
-            if (-not $h) { continue }
-            $o[$h] = $arr[$i]
-        }
-        $out.Add([pscustomobject]$o)
-    }
-
-    return $out.ToArray()
-}
-
-function Get-MarkerValue {
-    <#
-      05_SampleIdMarkers.csv schema:
-        AssayPattern,MarkerType,Marker,SampleTokenIndex,Enabled,Note
-      Returns the first enabled marker matching assay pattern + marker type (by RuleBank ordering / priority).
-    #>
-    param(
-        [Parameter(Mandatory)][pscustomobject]$RuleBank,
-        [Parameter(Mandatory)][string]$Assay,
-        [Parameter(Mandatory)][string]$MarkerType
-    )
-
-    foreach ($r in $RuleBank.SampleIdMarkers) {
-        if (-not (Test-RuleEnabled $r)) { continue }
-
-        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
-        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
-
-        $mt = ((Get-RowField -Row $r -FieldName 'MarkerType') + '').Trim()
-        if (-not $mt) { continue }
-        if ($mt -ine $MarkerType) { continue }
-
-        $m = ((Get-RowField -Row $r -FieldName 'Marker') + '').Trim()
-        return $m
-    }
-
-    return ''
-}
-
-function Get-IntMarkerValue {
-    param(
-        [Parameter(Mandatory)][pscustomobject]$RuleBank,
-        [Parameter(Mandatory)][string]$Assay,
-        [Parameter(Mandatory)][string]$MarkerType,
-        [Parameter(Mandatory)][int]$Default
-    )
-    $v = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType $MarkerType
-    if (-not $v) { return $Default }
-    try { return [int]$v } catch { return $Default }
-}
-
-function Get-ParityConfigForAssay {
-    <#
-      06_ParityCheckConfig.csv schema:
-        AssayPattern,Enabled,CartridgeField,SampleTokenIndex,SuffixX,SuffixPlus,DelaminationMarkerType,MinValidCartridgeSNPercent,Note,Priority
-    #>
-    param(
-        [Parameter(Mandatory)][pscustomobject]$RuleBank,
-        [Parameter(Mandatory)][string]$Assay
-    )
-
-    $cfg = [ordered]@{
-        UseParity = $false
-        CartridgeField = 'Cartridge S/N'
-        TokenIndex = 3
-        XChar = 'X'
-        PlusChar = '+'
-        NumericRatioThreshold = 0.60
-        DelaminationMarkerType = 'DelaminationCodeRegex'
-        DelamRegex = 'D\d{1,2}[A-Z]?'
-        ValidSuffixRegex = 'X|\+'
-        SampleTypeCodeTokenIndex = 2
-        SampleNumberTokenIndex = 3
-    }
-
-    # Pull defaults from markers (assay-aware)
-    $delam = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'DelaminationCodeRegex'
-    if ($delam) { $cfg.DelamRegex = $delam }
-
-    $suffix = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SuffixChars'
-    if ($suffix) {
-        # Some CSV exports double-escape backslashes (e.g. X|\+). Normalize "\" -> "\" for regex use.
-        while ($suffix -like '*\\*') { $suffix = $suffix.Replace('\\','\') }
-        $cfg.ValidSuffixRegex = $suffix
-    }
-
-    $stIdx = Get-IntMarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SampleTypeCodeTokenIndex' -Default 2
-    $snIdx = Get-IntMarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SampleNumberTokenIndex' -Default 3
-    $cfg.SampleTypeCodeTokenIndex = $stIdx
-    $cfg.SampleNumberTokenIndex = $snIdx
-
-    foreach ($r in $RuleBank.ParityCheckConfig) {
-        if (-not (Test-RuleEnabled $r)) { continue }
-
-        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
-        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
-
-        # First match wins since RuleBank.ParityCheckConfig is priority-sorted DESC.
-        $cfg.UseParity = $true
-
-        $cf = ((Get-RowField -Row $r -FieldName 'CartridgeField') + '').Trim()
-        if ($cf) { $cfg.CartridgeField = $cf }
-
-        $ti = ((Get-RowField -Row $r -FieldName 'SampleTokenIndex') + '').Trim()
-        if ($ti) { try { $cfg.TokenIndex = [int]$ti } catch {} }
-
-        $sx = ((Get-RowField -Row $r -FieldName 'SuffixX') + '').Trim()
-        if ($sx) { $cfg.XChar = $sx.Substring(0,1).ToUpperInvariant() }
-
-        $sp = ((Get-RowField -Row $r -FieldName 'SuffixPlus') + '').Trim()
-        if ($sp) { $cfg.PlusChar = $sp.Substring(0,1) }
-
-        $dmt = ((Get-RowField -Row $r -FieldName 'DelaminationMarkerType') + '').Trim()
-        if ($dmt) { $cfg.DelaminationMarkerType = $dmt }
-
-        $minPct = ((Get-RowField -Row $r -FieldName 'MinValidCartridgeSNPercent') + '').Trim()
-        if ($minPct) {
-            try { $cfg.NumericRatioThreshold = ([double]$minPct) / 100.0 } catch {}
-        }
-
-        break
-    }
-
-    # Refresh delam regex by configured marker type
-    if ($cfg.DelaminationMarkerType) {
-        $delam2 = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType $cfg.DelaminationMarkerType
-        if ($delam2) { $cfg.DelamRegex = $delam2 }
-    }
-
-    return [pscustomobject]$cfg
-}
-
-function Get-ControlCodeFromRow {
-    param(
-        [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][int]$SampleTypeCodeTokenIndex
-    )
-
-    $sid = (Get-RowField -Row $Row -FieldName 'Sample ID')
-    if (($sid + '').Trim()) {
-        $parts = ($sid + '').Split('_')
-        if ($parts.Count -gt $SampleTypeCodeTokenIndex) {
-            $cc = ($parts[$SampleTypeCodeTokenIndex] + '').Trim()
-            if ($cc -match '^\d+$') { return $cc }
-        }
-        # Legacy: token2 is commonly sample type code
-        if ($parts.Count -ge 3) {
-            $cc2 = ($parts[2] + '').Trim()
-            if ($cc2 -match '^\d+$') { return $cc2 }
-        }
-    }
-
-    $tt = (Get-RowField -Row $Row -FieldName 'Test Type')
-    if (($tt + '') -match '(?i)Negative\s+Control') { return '0' }
-    if (($tt + '') -match '(?i)Positive\s+Control\s+(\d+)') { return $Matches[1] }
-
-    return ''
-}
-
-function Get-SampleTokenAndBase {
-    param(
-        [Parameter(Mandatory)][string]$SampleId,
-        [Parameter(Mandatory)][int]$TokenIndex,
-        [Parameter(Mandatory)][string]$DelamPattern,
-        [Parameter(Mandatory)][string]$ValidSuffixRegex,
-        [Parameter(Mandatory)][string]$XChar,
-        [Parameter(Mandatory)][string]$PlusChar
-    )
-
-    $tok = ''
-    $base = ''
-
-    $parts = $SampleId.Split('_')
-    if ($parts.Count -gt $TokenIndex) {
-        $tok = ($parts[$TokenIndex] + '').Trim()
-    }
-
-    if (-not $tok) { return [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw=''; } }
-
-    # strip trailing delamination code if present INSIDE token
-    $rx = "([_-]?(?:" + $DelamPattern + "))$"
-    try {
-        $base = [regex]::Replace($tok, $rx, '', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
-    } catch {
-        $base = $tok
-    }
-
-    $base = ($base + '').Trim()
-
-    $act = ''
-    if ($base.Length -ge 1) {
-        $last = $base.Substring($base.Length - 1, 1)
-        if ($last -match ('^(?:' + $ValidSuffixRegex + ')$')) {
-            $u = $last.ToUpperInvariant()
-            if ($u -eq $XChar.ToUpperInvariant()) { $act = $XChar.ToUpperInvariant() }
-            elseif ($last -eq $PlusChar) { $act = $PlusChar }
-            else { $act = $u }
-        }
-    }
-
-    $numRaw = ''
-    $num = ''
-    if ($base -match '^(\d{1,4})') {
-        $numRaw = $Matches[1]
-        $num = $numRaw
-    }
-
-    return [pscustomobject]@{ SampleToken=$tok; BaseToken=$base; ActualSuffix=$act; SampleNum=$num; SampleNumRaw=$numRaw }
-}
-
-function Get-SampleNumberRuleForRow {
-    <#
-      07_SampleNumberRules.csv schema:
-        AssayPattern,SampleTypeCode,SampleNumberTokenIndex,SampleNumberRegex,SampleNumberMin,SampleNumberMax,SampleNumberPad,Enabled,Note,Priority
-    #>
-    param(
-        [Parameter(Mandatory)][string]$Assay,
-        [Parameter(Mandatory)][string]$ControlCode,
-        [Parameter(Mandatory)][object[]]$Rules
-    )
-
-    foreach ($r in $Rules) {
-        if (-not (Test-RuleEnabled $r)) { continue }
-
-        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
-        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
-
-        $cc = ((Get-RowField -Row $r -FieldName 'SampleTypeCode') + '').Trim()
-        if (-not $cc -or $cc -eq '*') { return $r }
-        if ($ControlCode -and ($cc -eq $ControlCode)) { return $r }
-    }
-
-    return $null
-}
-
-function Invoke-RuleEngine {
-    param(
-        [Parameter(Mandatory=$true)][AllowEmptyCollection()][object[]]$CsvObjects,
-        [Parameter(Mandatory)][pscustomobject]$RuleBank,
-        [Parameter(Mandatory=$false)][string]$CsvPath
-    )
-
-    if (-not $CsvObjects -or $CsvObjects.Count -eq 0) {
-        return [pscustomobject]@{ Rows=@(); Summary=[pscustomobject]@{ Total=0; ObservedCounts=@{}; DeviationCounts=@{}; RetestYes=0 }; TopDeviations=@() }
-    }
-
-    # Convert field-arrays (from Import-CsvRows) to objects using header from file
-    $needsConvert = $false
-    try {
-        if ($CsvObjects[0] -is [object[]]) { $needsConvert = $true }
-        else {
-            $p1 = $CsvObjects[0].PSObject.Properties.Match('Sample ID')
-            if ($p1.Count -eq 0) { $needsConvert = $true }
-        }
-    } catch { $needsConvert = $true }
-
-    if ($needsConvert) {
-        if (-not $CsvPath) { throw 'RuleEngine: CsvPath is required to convert field-array rows to objects.' }
-        $hdr = Get-HeaderFromTestSummaryFile -CsvPath $CsvPath
-        if (-not $hdr -or $hdr.Count -lt 5) { throw 'RuleEngine: Could not read CSV header (line 8).' }
-        $CsvObjects = Convert-FieldRowsToObjects -FieldRows $CsvObjects -Headers $hdr
-        if (-not $CsvObjects -or $CsvObjects.Count -eq 0) {
-            return [pscustomobject]@{ Rows=@(); Summary=[pscustomobject]@{ Total=0; ObservedCounts=@{}; DeviationCounts=@{}; RetestYes=0 }; TopDeviations=@() }
-        }
-    }
-
-    # Group by assay: parity + suffix expectations are assay-configurable.
-    $byAssay = @{}
-    foreach ($row in $CsvObjects) {
-        $a = (Get-RowField -Row $row -FieldName 'Assay')
-        $key = (($a + '').Trim())
-        if (-not $key) { $key = '(blank)' }
-        if (-not $byAssay.ContainsKey($key)) { $byAssay[$key] = New-Object System.Collections.Generic.List[object] }
-        $byAssay[$key].Add($row)
-    }
-
-    $results = New-Object System.Collections.Generic.List[object]
-    $errLut = Build-ErrorCodeLookup -ErrorCodes $RuleBank.ErrorCodes
-
-    foreach ($assayKey in $byAssay.Keys) {
-        $group = $byAssay[$assayKey]
-        if (-not $group -or $group.Count -eq 0) { continue }
-
-        $parCfg = Get-ParityConfigForAssay -RuleBank $RuleBank -Assay $assayKey
-        $delamPattern = $parCfg.DelamRegex
-        $validSuffix = $parCfg.ValidSuffixRegex
-
-        # Pre-scan for parity + majority suffix
-        $numeric = New-Object System.Collections.Generic.List[long]
-        $suffixCounts = @{}
-        $suffixCounts[$parCfg.XChar.ToUpperInvariant()] = 0
-        $suffixCounts[$parCfg.PlusChar] = 0
-
-        foreach ($row in $group) {
-            $sn = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
-            if (($sn + '').Trim() -match '^\d+$') {
-                try { $numeric.Add([long]($sn + '')) } catch {}
-            }
-
-            $sid = (Get-RowField -Row $row -FieldName 'Sample ID')
-            if (($sid + '').Trim()) {
-                $t = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $parCfg.TokenIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
-                if ($t.ActualSuffix -and $suffixCounts.ContainsKey($t.ActualSuffix)) { $suffixCounts[$t.ActualSuffix]++ }
-            }
-        }
-
-        $numRatio = 0.0
-        try { $numRatio = [double]$numeric.Count / [double]$group.Count } catch {}
-
-        $useParity = ($parCfg.UseParity -and $numeric.Count -gt 0 -and $numRatio -ge $parCfg.NumericRatioThreshold)
-
-        $minSn = $null
-        $parityForX = $null
-        if ($useParity) {
-            try {
-                $minSn = ($numeric | Measure-Object -Minimum).Minimum
-                $parityForX = [int]($minSn % 2)
-            } catch {
-                $useParity = $false
-            }
-        }
-
-        $majSuffix = ''
-        if (-not $useParity) {
-            $xCount = $suffixCounts[$parCfg.XChar.ToUpperInvariant()]
-            $pCount = $suffixCounts[$parCfg.PlusChar]
-            if ($xCount -gt $pCount) { $majSuffix = $parCfg.XChar.ToUpperInvariant() }
-            elseif ($pCount -gt $xCount) { $majSuffix = $parCfg.PlusChar }
-        }
-
-        foreach ($row in $group) {
-            try {
-                $obsD = Get-ObservedCallDetailed -Row $row -Patterns $RuleBank.ResultCallPatterns
-                $expD = Get-ExpectedCallDetailed -Row $row -Rules $RuleBank.SampleExpectationRules
-
-                $sid = (Get-RowField -Row $row -FieldName 'Sample ID')
-                $assay = (Get-RowField -Row $row -FieldName 'Assay')
-
-                $expTT = ''
-                if (($sid + '').Trim()) { $expTT = Get-ExpectedTestTypeDerived -SampleId ($sid + '') }
-
-                # ExpectedCall fallback: derive from Test Type / control code when no explicit rule matched
-                $expCall = ($expD.Call + '').Trim().ToUpperInvariant()
-                $expSrc = 'RULE'
-                if (-not $expCall) {
-                    $tt = (Get-RowField -Row $row -FieldName 'Test Type')
-                    $tt2 = ($tt + '')
-                    if ($tt2 -match '(?i)Negative\s+Control') { $expCall = 'NEG'; $expSrc = 'TESTTYPE' }
-                    elseif ($tt2 -match '(?i)Positive\s+Control') { $expCall = 'POS'; $expSrc = 'TESTTYPE' }
-                    else {
-                        $cc2 = Get-ControlCodeFromRow -Row $row -SampleTypeCodeTokenIndex $parCfg.SampleTypeCodeTokenIndex
-                        if ($cc2 -match '^\d+$') {
-                            if ([int]$cc2 -eq 0) { $expCall = 'NEG'; $expSrc = 'CONTROL_CODE' }
-                            elseif ([int]$cc2 -ge 1) { $expCall = 'POS'; $expSrc = 'CONTROL_CODE' }
-                        }
-                    }
-                }
-
-                $errInfo = Get-ErrorInfo -Row $row -ErrorLut $errLut -DelamPattern $delamPattern
-                $dev = Classify-Deviation -Expected $expCall -Observed $obsD.Call
-
-                # Suffix / parity validation (naming robustness)
-                $tokInfo = [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw='' }
-                if (($sid + '').Trim()) {
-                    $tokInfo = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $parCfg.TokenIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
-                }
-
-                $expectedSuffix = ''
-                $suffixSource = ''
-                $suffixCheck = ''
-
-                $snVal = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
-                $snNum = $null
-                if (($snVal + '').Trim() -match '^\d+$') { try { $snNum = [long]($snVal + '') } catch {} }
-
-                if ($tokInfo.ActualSuffix) {
-                    if ($useParity -and $snNum -ne $null -and $parityForX -ne $null) {
-                        $expS = if (([int]($snNum % 2)) -eq $parityForX) { $parCfg.XChar.ToUpperInvariant() } else { $parCfg.PlusChar }
-                        $expectedSuffix = $expS
-                        $suffixSource = 'PARITY'
-                    } elseif ($majSuffix) {
-                        $expectedSuffix = $majSuffix
-                        $suffixSource = 'MAJORITY'
-                    }
-
-                    if ($expectedSuffix) {
-                        $suffixCheck = if ($tokInfo.ActualSuffix -eq $expectedSuffix) { 'OK' } else { 'BAD' }
-                    }
-                }
-
-                # Sample number validation (config-driven)
-                $sampleNum = ''
-                $sampleNumRaw = ''
-                $sampleNumOk = ''
-                $sampleNumWhy = ''
-
-                $cc = Get-ControlCodeFromRow -Row $row -SampleTypeCodeTokenIndex $parCfg.SampleTypeCodeTokenIndex
-
-                $rule = $null
-                try { $rule = Get-SampleNumberRuleForRow -Assay $assay -ControlCode $cc -Rules $RuleBank.SampleNumberRules } catch {}
-
-                $snTokIndex = $parCfg.SampleNumberTokenIndex
-                if ($rule) {
-                    $idxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberTokenIndex') + '').Trim()
-                    if ($idxTxt) { try { $snTokIndex = [int]$idxTxt } catch {} }
-                }
-
-                $snInfo = [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw='' }
-                if (($sid + '').Trim()) {
-                    $snInfo = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $snTokIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
-                }
-                $sampleNum = $snInfo.SampleNum
-                $sampleNumRaw = $snInfo.SampleNumRaw
-
-                if ($rule) {
-                    $rxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberRegex') + '').Trim()
-                    $minTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberMin') + '').Trim()
-                    $maxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberMax') + '').Trim()
-                    $padTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberPad') + '').Trim()
-
-                    $min = 0; $max = 0; $pad = 0
-                    try { $min = [int]$minTxt } catch {}
-                    try { $max = [int]$maxTxt } catch {}
-                    try { $pad = [int]$padTxt } catch {}
-
-                    if (-not $sampleNum) {
-                        $sampleNumOk = 'NO'
-                        $sampleNumWhy = 'No sample number'
-                    } else {
-                        $numInt = 0
-                        try { $numInt = [int]$sampleNum } catch { $numInt = 0 }
-
-                        $rxOk = $true
-                        if ($rxTxt) {
-                            try { $rxOk = [regex]::IsMatch(($snInfo.BaseToken + ''), $rxTxt, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } catch { $rxOk = $true }
-                        }
-
-                        $padOk = $true
-                        if ($pad -gt 0 -and ($sampleNumRaw + '').Length -ne $pad) { $padOk = $false }
-
-                        if ($rxOk -and $padOk -and $min -gt 0 -and $max -gt 0 -and $numInt -ge $min -and $numInt -le $max) {
-                            $sampleNumOk = 'YES'
-                        } else {
-                            $sampleNumOk = 'NO'
-                            $sampleNumWhy = 'Out of range/regex/pad'
-                        }
-                    }
-                }
-
-                $results.Add([pscustomobject]@{
-                    SampleId         = $sid
-                    CartridgeSN      = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
-                    Assay            = $assay
-                    AssayVersion     = (Get-RowField -Row $row -FieldName 'Assay Version')
-                    ReagentLotId     = (Get-RowField -Row $row -FieldName 'Reagent Lot ID')
-                    TestType         = (Get-RowField -Row $row -FieldName 'Test Type')
-                    ExpectedTestType = $expTT
-                    ControlCode      = $cc
-                    SampleToken      = $tokInfo.SampleToken
-                    BaseToken        = $tokInfo.BaseToken
-                    ActualSuffix     = $tokInfo.ActualSuffix
-                    ExpectedSuffix   = $expectedSuffix
-                    SuffixCheck      = $suffixCheck
-                    SuffixSource     = $suffixSource
-                    SampleNum        = $sampleNum
-                    SampleNumOK      = $sampleNumOk
-                    SampleNumWhy     = $sampleNumWhy
-                    Status           = (Get-RowField -Row $row -FieldName 'Status')
-                    TestResult       = (Get-RowField -Row $row -FieldName 'Test Result')
-                    ErrorText        = (Get-RowField -Row $row -FieldName 'Error')
-                    MaxPressure      = $errInfo.MaxPressure
-                    PressureFlag     = $errInfo.PressureFlag
-                    ErrorCode        = $errInfo.ErrorCode
-                    ErrorName        = $errInfo.ErrorName
-                    GeneratesRetest  = $errInfo.GeneratesRetest
-                    ObservedCall     = $obsD.Call
-                    ObservedWhy      = $obsD.Reason
-                    ExpectedCall     = $expCall
-                    ExpectedWhy      = $expD.Reason
-                    ExpectedSource   = $expSrc
-                    Deviation        = $dev
-                    ModuleSN         = (Get-RowField -Row $row -FieldName 'Module S/N')
-                    StartTime        = (Get-RowField -Row $row -FieldName 'Start Time')
-                    RuleFlags        = ''
-                })
-
-            } catch {
-                $sid2 = ''
-                try { $sid2 = (Get-RowField -Row $row -FieldName 'Sample ID') } catch {}
-                throw ("RuleEngine row-fel (Sample ID=" + $sid2 + "): " + $_.Exception.Message)
-            }
-        }
-    }
-
-
-
-    # --- QC post-processing (file-level validations + per-row flags) ---
-    function _Append-RuleFlag {
-        param([pscustomobject]$row, [string]$flag)
-        $f = (($row.RuleFlags + '')).Trim()
-        if (-not $f) { $row.RuleFlags = $flag; return }
-        $parts = $f.Split('|')
-        if ($parts -contains $flag) { return }
-        $row.RuleFlags = ($f + '|' + $flag)
-    }
-
-    # Distinct counts (file-level)
-    $distinctAssays = @($results | ForEach-Object { ($_.Assay + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
-    $distinctAssayVersions = @($results | ForEach-Object { ($_.AssayVersion + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
-    $distinctReagentLots = @($results | ForEach-Object { ($_.ReagentLotId + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
-
-    # Duplicate Sample IDs
-    $dupSample = @($results | Where-Object { (($_.SampleId + '').Trim()) } | Group-Object SampleId | Where-Object { $_.Count -gt 1 })
-    if ($dupSample.Count -gt 0) {
-        $dupSet = @{}
-        foreach ($g in $dupSample) { $dupSet[$g.Name] = $true }
-        foreach ($r in $results) {
-            $sid = ((($r.SampleId + '')).Trim())
-            if ($sid -and $dupSet.ContainsKey($sid)) { _Append-RuleFlag -row $r -flag 'DQ_DUP_SAMPLEID' }
-        }
-    }
-
-    # Duplicate Cartridge S/N
-    $dupCart = @($results | Where-Object { (($_.CartridgeSN + '').Trim()) } | Group-Object CartridgeSN | Where-Object { $_.Count -gt 1 })
-    if ($dupCart.Count -gt 0) {
-        $dupSet = @{}
-        foreach ($g in $dupCart) { $dupSet[$g.Name] = $true }
-        foreach ($r in $results) {
-            $csn = ((($r.CartridgeSN + '')).Trim())
-            if ($csn -and $dupSet.ContainsKey($csn)) { _Append-RuleFlag -row $r -flag 'DQ_DUP_CARTSN' }
-        }
-    }
-
-    # Test Type mismatch (derived expected vs actual)
-    foreach ($r in $results) {
-        $act = ((($r.TestType + '')).Trim())
-        $exp = ((($r.ExpectedTestType + '')).Trim())
-        if ($act -and $exp -and ($act.ToUpperInvariant() -ne $exp.ToUpperInvariant())) {
-            _Append-RuleFlag -row $r -flag 'TESTTYPE_MISMATCH'
-        }
-    }
-
-    # Module hotspot: >=3 ERROR rows on same Module S/N
-    $hotModules = @{}
-    $byModErr = @($results | Where-Object { (($_.ModuleSN + '').Trim()) -and (($_.ObservedCall + '').Trim().ToUpperInvariant() -eq 'ERROR') } | Group-Object ModuleSN)
-    foreach ($g in $byModErr) {
-        if ($g.Count -ge 3) { $hotModules[$g.Name] = $g.Count }
-    }
-    if ($hotModules.Count -gt 0) {
-        foreach ($r in $results) {
-            $m = ((($r.ModuleSN + '')).Trim())
-            if ($m -and $hotModules.ContainsKey($m)) { _Append-RuleFlag -row $r -flag 'MODULE_ERR_HOTSPOT' }
-        }
-    }
-
-    # Attach QC stats to result (used by Debug sheet summary)
-    $qc = [pscustomobject]@{
-        DistinctAssays = $distinctAssays
-        DistinctAssayVersions = $distinctAssayVersions
-        DistinctReagentLots = $distinctReagentLots
-        DuplicateSampleIdCount = ($dupSample | ForEach-Object { $_.Name } | Select-Object -Unique).Count
-        DuplicateCartridgeSnCount = ($dupCart | ForEach-Object { $_.Name } | Select-Object -Unique).Count
-        HotModuleCount = $hotModules.Count
-    }
-    # ---------------------------------------------------------------
-    $summary = [pscustomobject]@{
-        Total = $results.Count
-        ObservedCounts = @{}
-        DeviationCounts = @{}
-        RetestYes = 0
-    }
-
-    foreach ($r in $results) {
-        if (-not $summary.ObservedCounts.ContainsKey($r.ObservedCall)) { $summary.ObservedCounts[$r.ObservedCall] = 0 }
-        $summary.ObservedCounts[$r.ObservedCall]++
-
-        if (-not $summary.DeviationCounts.ContainsKey($r.Deviation)) { $summary.DeviationCounts[$r.Deviation] = 0 }
-        $summary.DeviationCounts[$r.Deviation]++
-
-        $rt = ($r.GeneratesRetest + '').Trim().ToUpperInvariant()
-        if ($rt -in @('YES','Y','TRUE','1')) { $summary.RetestYes++ }
-    }
-
-    $top = @($results | Where-Object { $_.Deviation -in @('FP','FN','ERROR','MISMATCH') } | Select-Object -First 50)
-
-    return [pscustomobject]@{ Rows = $results.ToArray(); Summary = $summary; TopDeviations = $top; QC = $qc }
-}
-
-function Write-RuleEngineDebugSheet {
-    param(
-        [Parameter(Mandatory)][object]$Pkg,
-        [Parameter(Mandatory)][pscustomobject]$RuleEngineResult,
-        [Parameter(Mandatory=$false)][bool]$IncludeAllRows = $false
-    )
-
-    try {
-        $old = $Pkg.Workbook.Worksheets['RuleEngine_Debug']
-        if ($old) { $Pkg.Workbook.Worksheets.Delete($old) }
-    } catch {}
-
-    $ws = $Pkg.Workbook.Worksheets.Add('RuleEngine_Debug')
-
-    $headers = @(
-        '#','Sample ID','Cartridge S/N','Module S/N','Start Time',
-        'Test Type','Expected Test Type','ControlCode',
-        'SampleToken','BaseToken','ActualSuffix','ExpectedSuffix','SuffixCheck','SuffixSource',
-        'SampleNum','SampleNumOK','SampleNumWhy',
-        'Expected Call','ExpectedSource','Observed Call','ObservedWhy','Deviation','RuleFlags',
-        'Status','ErrorCode','ErrorName','Retest','Max Pressure','PressureFlag',
-        'Test Result','Error'
-    )
-
-    # --- Summary section (always written, even when exception-only table has 0 rows) ---
-    $row = 1
-    $ws.Cells[$row,1].Value = 'RuleEngine Debug Summary'
-    $ws.Cells[$row,1].Style.Font.Bold = $true
-    $row++
-
-    $sum = $RuleEngineResult.Summary
-    $qc  = $RuleEngineResult.QC
-
-    function _WriteKV {
-        param([int]$r, [string]$k, $v)
-        $ws.Cells[$r,1].Value = $k
-        $ws.Cells[$r,2].Value = $v
-        $ws.Cells[$r,1].Style.Font.Bold = $true
-    }
-
-    _WriteKV -r $row -k 'Total tests' -v $sum.Total; $row++
-
-    foreach ($k in @('OK','FP','FN','ERROR','MISMATCH','UNKNOWN')) {
-        if ($sum.DeviationCounts.ContainsKey($k)) { _WriteKV -r $row -k ('Deviation ' + $k) -v $sum.DeviationCounts[$k]; $row++ }
-    }
-
-    foreach ($k in @('POS','NEG','ERROR','UNKNOWN')) {
-        if ($sum.ObservedCounts.ContainsKey($k)) { _WriteKV -r $row -k ('Observed ' + $k) -v $sum.ObservedCounts[$k]; $row++ }
-    }
-
-    _WriteKV -r $row -k 'Retest YES' -v $sum.RetestYes; $row++
-
-    if ($qc) {
-        _WriteKV -r $row -k 'Assays (distinct)' -v ($qc.DistinctAssays.Count); $row++
-        _WriteKV -r $row -k 'Assay versions (distinct)' -v ($qc.DistinctAssayVersions.Count); $row++
-        _WriteKV -r $row -k 'Reagent lots (distinct)' -v ($qc.DistinctReagentLots.Count); $row++
-        _WriteKV -r $row -k 'Duplicate Sample IDs' -v $qc.DuplicateSampleIdCount; $row++
-        _WriteKV -r $row -k 'Duplicate Cartridge S/N' -v $qc.DuplicateCartridgeSnCount; $row++
-        _WriteKV -r $row -k 'Hot modules (>=3 errors)' -v $qc.HotModuleCount; $row++
-
-        if ($qc.DistinctAssays.Count -gt 1) { _WriteKV -r $row -k 'Assay list' -v ($qc.DistinctAssays -join ', '); $row++ }
-        if ($qc.DistinctAssayVersions.Count -gt 1) { _WriteKV -r $row -k 'Assay version list' -v ($qc.DistinctAssayVersions -join ', '); $row++ }
-        if ($qc.DistinctReagentLots.Count -gt 1) { _WriteKV -r $row -k 'Reagent lot list' -v ($qc.DistinctReagentLots -join ', '); $row++ }
-    }
-
-    $row++
-    $tableHeaderRow = $row
-
-    for ($c = 1; $c -le $headers.Count; $c++) {
-        $ws.Cells[$tableHeaderRow,$c].Value = $headers[$c-1]
-        $ws.Cells[$tableHeaderRow,$c].Style.Font.Bold = $true
-    }
-
-    $rows = $RuleEngineResult.Rows
-
-    # --- Exception-based filter (does NOT modify RuleEngineResult) ---
-    $rowsToWrite = $rows
-    if (-not $IncludeAllRows) {
-        $rowsToWrite = @($rows | Where-Object {
-            $dev = (($_.Deviation + '')).Trim().ToUpperInvariant()
-            $hasDeviation = ($dev.Length -gt 0 -and $dev -ne 'OK')
-
-            $obs = (($_.ObservedCall + '')).Trim().ToUpperInvariant()
-            $observedErr = ($obs -eq 'ERROR')
-
-            $pressureFlag = $false
-            try { $pressureFlag = [bool]$_.PressureFlag } catch { $pressureFlag = $false }
-
-            $hasErrorCode = ((($_.ErrorCode + '')).Trim().Length -gt 0)
-
-            $st = (($_.Status + '')).Trim()
-            $statusNotDone = ($st.Length -gt 0 -and $st -ne 'Done')
-
-            $retestTrue = $false
-            $rt = (($_.GeneratesRetest + '')).Trim().ToUpperInvariant()
-            if ($rt -in @('YES','Y','TRUE','1')) { $retestTrue = $true }
-
-            $rf = (($_.RuleFlags + '')).Trim()
-            $hasRuleFlags = ($rf.Length -gt 0)
-
-            return ($hasDeviation -or $observedErr -or $pressureFlag -or $hasErrorCode -or $statusNotDone -or $retestTrue -or $hasRuleFlags)
-        })
-    }
-
-    if (-not $rowsToWrite -or $rowsToWrite.Count -eq 0) {
-        $ws.Cells[$tableHeaderRow+1,2].Value = 'No deviations found'
-        $ws.Cells[$tableHeaderRow+1,2].Style.Font.Italic = $true
-        try { if ($ws.Dimension) { $ws.Cells[$ws.Dimension.Address].AutoFitColumns() } } catch {}
-        return $ws
-    }
-
-    $rOut = $tableHeaderRow + 1
-    $idx = 1
-
-    foreach ($r in $rowsToWrite) {
-        $ws.Cells[$rOut,1].Value  = $idx
-        $ws.Cells[$rOut,2].Value  = ($r.SampleId + '')
-        $ws.Cells[$rOut,3].Value  = ($r.CartridgeSN + '')
-        $ws.Cells[$rOut,4].Value  = ($r.ModuleSN + '')
-        $ws.Cells[$rOut,5].Value  = ($r.StartTime + '')
-
-        $ws.Cells[$rOut,6].Value  = ($r.TestType + '')
-        $ws.Cells[$rOut,7].Value  = ($r.ExpectedTestType + '')
-        $ws.Cells[$rOut,8].Value  = ($r.ControlCode + '')
-
-        $ws.Cells[$rOut,9].Value  = ($r.SampleToken + '')
-        $ws.Cells[$rOut,10].Value = ($r.BaseToken + '')
-        $ws.Cells[$rOut,11].Value = ($r.ActualSuffix + '')
-        $ws.Cells[$rOut,12].Value = ($r.ExpectedSuffix + '')
-        $ws.Cells[$rOut,13].Value = ($r.SuffixCheck + '')
-        $ws.Cells[$rOut,14].Value = ($r.SuffixSource + '')
-
-        $ws.Cells[$rOut,15].Value = ($r.SampleNum + '')
-        $ws.Cells[$rOut,16].Value = ($r.SampleNumOK + '')
-        $ws.Cells[$rOut,17].Value = ($r.SampleNumWhy + '')
-
-        $ws.Cells[$rOut,18].Value = ($r.ExpectedCall + '')
-        $ws.Cells[$rOut,19].Value = ($r.ExpectedSource + '')
-        $ws.Cells[$rOut,20].Value = ($r.ObservedCall + '')
-        $ws.Cells[$rOut,21].Value = ($r.ObservedWhy + '')
-        $ws.Cells[$rOut,22].Value = ($r.Deviation + '')
-        $ws.Cells[$rOut,23].Value = ($r.RuleFlags + '')
-
-        $ws.Cells[$rOut,24].Value = ($r.Status + '')
-        $ws.Cells[$rOut,25].Value = ($r.ErrorCode + '')
-        $ws.Cells[$rOut,26].Value = ($r.ErrorName + '')
-        $ws.Cells[$rOut,27].Value = ($r.GeneratesRetest + '')
-        $ws.Cells[$rOut,28].Value = $(if ($null -ne $r.MaxPressure) { $r.MaxPressure } else { '' })
-        $ws.Cells[$rOut,29].Value = $(if ($r.PressureFlag) { 'YES' } else { '' })
-
-        $ws.Cells[$rOut,30].Value = ($r.TestResult + '')
-        $ws.Cells[$rOut,31].Value = ($r.ErrorText + '')
-
-        $rOut++; $idx++
-    }
-
-    try { if ($ws.Dimension) { $ws.Cells[$ws.Dimension.Address].AutoFitColumns() } } catch {}
-    return $ws
+ï»¿# RuleEngine.ps1 (Windows PowerShell 5.1)
+# Shadow-mode RuleEngine + RuleBank (CSV-driven)
+# - Does NOT change legacy report logic unless explicitly wired
+# - Produces per-row: ObservedCall, ExpectedCall, Deviation, ErrorCode/RetestPolicy
+# - Writes RuleEngine_Debug worksheet (shadow)
+
+function Import-RuleCsv {
+    param([Parameter(Mandatory)][string]$Path)
+    if (-not (Test-Path -LiteralPath $Path)) { return @() }
+
+    $delim = ','
+    try { $delim = Get-CsvDelimiter -Path $Path } catch {}
+
+    try {
+        $lines = Get-Content -LiteralPath $Path -ErrorAction Stop
+        if (-not $lines -or $lines.Count -lt 1) { return @() }
+        return @(ConvertFrom-Csv -InputObject ($lines -join "`n") -Delimiter $delim)
+    } catch {
+        try { return @(Import-Csv -LiteralPath $Path -Delimiter $delim) } catch { return @() }
+    }
+}
+
+function Load-RuleBank {
+    param([Parameter(Mandatory)][string]$RuleBankDir)
+
+    $rb = [ordered]@{
+        Dir = $RuleBankDir
+        ResultCallPatterns = @()
+        AssayObservedCallRules = @()
+        SampleExpectationRules = @()
+        ErrorCodes = @()
+        MissingSamplesConfig = @()
+        SampleIdMarkers = @()
+        ParityCheckConfig = @()
+        SampleNumberRules = @()
+    }
+
+    if (-not (Test-Path -LiteralPath $RuleBankDir)) { return [pscustomobject]$rb }
+
+    $map = @{
+        ResultCallPatterns      = '01_ResultCallPatterns.csv'
+        AssayObservedCallRules  = '08_AssayObservedCallRules.csv'
+        SampleExpectationRules  = '02_SampleExpectationRules.csv'
+        ErrorCodes              = '03_ErrorCodes.csv'
+        MissingSamplesConfig    = '04_MissingSamplesConfig.csv'
+        SampleIdMarkers         = '05_SampleIdMarkers.csv'
+        ParityCheckConfig       = '06_ParityCheckConfig.csv'
+        SampleNumberRules       = '07_SampleNumberRules.csv'
+    }
+
+    foreach ($k in $map.Keys) {
+        $p = Join-Path $RuleBankDir $map[$k]
+        $rb[$k] = Import-RuleCsv -Path $p
+    }
+
+    # Priority sort where applicable
+    try { $rb.ResultCallPatterns = @($rb.ResultCallPatterns | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+    try { $rb.SampleExpectationRules = @($rb.SampleExpectationRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+    try { $rb.ParityCheckConfig = @($rb.ParityCheckConfig | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+    try { $rb.SampleIdMarkers = @($rb.SampleIdMarkers | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+    try { $rb.SampleNumberRules = @($rb.SampleNumberRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+
+    return [pscustomobject]$rb
+}
+
+function Get-RowField {
+    param(
+        [Parameter(Mandatory)][object]$Row,
+        [Parameter(Mandatory)][string]$FieldName
+    )
+    try {
+        $p = $Row.PSObject.Properties[$FieldName]
+        if ($p -and $null -ne $p.Value) { return $p.Value }
+    } catch {}
+    return ''
+}
+
+function Test-RuleEnabled {
+    param([Parameter(Mandatory)][object]$Rule)
+    $en = (Get-RowField -Row $Rule -FieldName 'Enabled')
+    if ($en -eq $null) { return $true }
+    $s = ($en + '').Trim().ToUpperInvariant()
+    if (-not $s) { return $true }
+    return ($s -in @('TRUE','1','YES','Y'))
+}
+
+function Test-AssayMatch {
+    <#
+      Supports:
+      - empty / '*' => match all
+      - wildcard patterns (contains '*' or '?') via -like
+      - otherwise case-insensitive equals
+    #>
+    param(
+        [Parameter(Mandatory)][string]$RuleAssay,
+        [Parameter(Mandatory)][string]$RowAssay
+    )
+    $ra = ($RuleAssay + '').Trim()
+    if (-not $ra -or $ra -eq '*') { return $true }
+
+    $row = ($RowAssay + '').Trim()
+    if ($ra -like '*[*?]*') {
+        return ($row -like $ra)
+    }
+    return ($ra -ieq $row)
+}
+
+function Match-Text {
+    param(
+        [Parameter(Mandatory)][string]$Text,
+        [Parameter(Mandatory)][string]$Pattern,
+        [Parameter(Mandatory)][string]$MatchType
+    )
+
+    $t = ($Text + '')
+    $p = ($Pattern + '')
+    $m = ($MatchType + '').Trim().ToUpperInvariant()
+    if (-not $m) { $m = 'CONTAINS' }
+
+    try {
+        switch ($m) {
+            'REGEX'  { return [regex]::IsMatch($t, $p, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) }
+            'EQUALS' { return (($t.Trim()).ToUpperInvariant() -eq ($p.Trim()).ToUpperInvariant()) }
+            'PREFIX' {
+                $tt = ($t.Trim()).ToUpperInvariant()
+                $pp = ($p.Trim()).ToUpperInvariant()
+                if (-not $pp) { return $true }
+                return ($tt.Length -ge $pp.Length -and $tt.Substring(0, $pp.Length) -eq $pp)
+            }
+            'SUFFIX' {
+                $tt = ($t.Trim()).ToUpperInvariant()
+                $pp = ($p.Trim()).ToUpperInvariant()
+                if (-not $pp) { return $true }
+                return ($tt.Length -ge $pp.Length -and $tt.Substring($tt.Length - $pp.Length) -eq $pp)
+            }
+            default {
+                return (($t.ToUpperInvariant()).Contains($p.ToUpperInvariant()))
+            }
+        }
+    } catch {
+        return $false
+    }
+}
+
+function Get-ObservedCallDetailed {
+    param(
+        [Parameter(Mandatory)][object]$Row,
+        [Parameter(Mandatory)][object[]]$Patterns,
+        [Parameter(Mandatory=$false)][object[]]$AssayObservedCallRules = $null
+    )
+
+    $status = (Get-RowField -Row $Row -FieldName 'Status')
+    $errTxt = (Get-RowField -Row $Row -FieldName 'Error')
+    $testResult = (Get-RowField -Row $Row -FieldName 'Test Result')
+    $assay = (Get-RowField -Row $Row -FieldName 'Assay')
+
+    if (($errTxt + '').Trim()) {
+        return [pscustomobject]@{ Call='ERROR'; Reason='Error column populated' }
+    }
+    $st = ($status + '').Trim()
+    if ($st -and ($st -ine 'Done')) {
+        return [pscustomobject]@{ Call='ERROR'; Reason=("Status=" + $st) }
+    }
+
+    $tr = ($testResult + '').Trim()
+    if (-not $tr) { return [pscustomobject]@{ Call='UNKNOWN'; Reason='Blank Test Result' } }
+
+    # MTB-family override: treat MTB DETECTED/TRACE DETECTED as POS even if RIF contains NOT DETECTED/INDETERMINATE.
+    # Prevent classic false INDET/NEG due to substring collisions.
+    $ass = ($assay + '')
+    if ($ass -match 'MTB') {
+        if ($tr -match '(?i)\bMTB\s+TRACE\s+DETECTED\b') {
+            return [pscustomobject]@{ Call='POS'; Reason='MTB Trace detected (override)' }
+        }
+        if ($tr -match '(?i)\bMTB\s+DETECTED\b') {
+            return [pscustomobject]@{ Call='POS'; Reason='MTB detected (override)' }
+        }
+        if ($tr -match '(?i)\bMTB\s+NOT\s+DETECTED\b') {
+            return [pscustomobject]@{ Call='NEG'; Reason='MTB not detected (override)' }
+        }
+    }
+
+    foreach ($r in $Patterns) {
+        if (-not (Test-RuleEnabled $r)) { continue }
+        $ruleAssay = (Get-RowField -Row $r -FieldName 'Assay')
+        if (-not (Test-AssayMatch -RuleAssay $ruleAssay -RowAssay $assay)) { continue }
+
+        $pat  = (Get-RowField -Row $r -FieldName 'Pattern')
+        if (-not ($pat + '').Trim()) { continue }
+        $mt   = (Get-RowField -Row $r -FieldName 'MatchType')
+
+        if (Match-Text -Text $tr -Pattern $pat -MatchType $mt) {
+            $call = ((Get-RowField -Row $r -FieldName 'Call') + '').Trim().ToUpperInvariant()
+            if ($call) {
+                $note = (Get-RowField -Row $r -FieldName 'Note')
+                $why = if (($note + '').Trim()) { $note } else { ("Matched " + $mt + ": " + $pat) }
+                return [pscustomobject]@{ Call=$call; Reason=$why }
+            }
+        }
+    }
+
+    # --- Assay-specific fallback (data-driven) ---
+    # If no ResultCallPatterns matched, try assay-driven keyword inference (NON-MTB only).
+    # This is driven by RuleBank: 08_AssayObservedCallRules.csv
+    if ($AssayObservedCallRules -and $AssayObservedCallRules.Count -gt 0) {
+        $assTxt = ($assay + '')
+        $assIsMTB = ($assTxt -match 'MTB')
+        if (-not $assIsMTB) {
+            $rule = $null
+            foreach ($r2 in $AssayObservedCallRules) {
+                if (-not (Test-RuleEnabled $r2)) { continue }
+                $ruleAssay = (Get-RowField -Row $r2 -FieldName 'AssayPattern')
+                if (-not ($ruleAssay + '').Trim()) { $ruleAssay = (Get-RowField -Row $r2 -FieldName 'Assay') }
+                if (-not (Test-AssayMatch -RuleAssay $ruleAssay -RowAssay $assay)) { continue }
+                $isMtbRule = ((Get-RowField -Row $r2 -FieldName 'IsMTB') + '').Trim().ToUpperInvariant()
+                if ($isMtbRule -in @('TRUE','1','YES','Y')) { continue } # keep MTB special logic elsewhere
+                $rule = $r2
+                break
+            }
+
+            if ($rule) {
+                $posRx = (Get-RowField -Row $rule -FieldName 'PosRegex')
+                $negRx = (Get-RowField -Row $rule -FieldName 'NegRegex')
+                $errRx = (Get-RowField -Row $rule -FieldName 'ErrRegex')
+                $posWins = (((Get-RowField -Row $rule -FieldName 'PosWins') + '').Trim().ToUpperInvariant() -in @('TRUE','1','YES','Y'))
+
+                $hitErr = $false
+                $hitPos = $false
+                $hitNeg = $false
+                try { if (($errRx + '').Trim()) { $hitErr = [regex]::IsMatch($tr, ($errRx + ''), [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } } catch {}
+                try { if (($posRx + '').Trim()) { $hitPos = [regex]::IsMatch($tr, ($posRx + ''), [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } } catch {}
+                try { if (($negRx + '').Trim()) { $hitNeg = [regex]::IsMatch($tr, ($negRx + ''), [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } } catch {}
+
+                if ($hitErr) {
+                    return [pscustomobject]@{ Call='ERROR'; Reason='AssayRules fallback: ErrRegex' }
+                }
+
+                if ($hitPos -and $hitNeg) {
+                    if ($posWins) {
+                        return [pscustomobject]@{ Call='POS'; Reason='AssayRules fallback: POS+NEG present (POS wins)' }
+                    } else {
+                        return [pscustomobject]@{ Call='UNKNOWN'; Reason='AssayRules fallback: POS+NEG present (no winner)' }
+                    }
+                }
+                if ($hitPos) {
+                    return [pscustomobject]@{ Call='POS'; Reason='AssayRules fallback: PosRegex' }
+                }
+                if ($hitNeg) {
+                    return [pscustomobject]@{ Call='NEG'; Reason='AssayRules fallback: NegRegex' }
+                }
+            }
+        }
+    }
+    # --- End assay-specific fallback ---
+
+    return [pscustomobject]@{ Call='UNKNOWN'; Reason='No pattern matched' }
+}
+
+function Get-ExpectedCallDetailed {
+    param(
+        [Parameter(Mandatory)][object]$Row,
+        [Parameter(Mandatory)][object[]]$Rules
+    )
+
+    $sampleId = (Get-RowField -Row $Row -FieldName 'Sample ID')
+    $assay    = (Get-RowField -Row $Row -FieldName 'Assay')
+    $sid = ($sampleId + '').Trim()
+    if (-not $sid) { return [pscustomobject]@{ Call=''; Reason='Blank Sample ID' } }
+
+    foreach ($r in $Rules) {
+        if (-not (Test-RuleEnabled $r)) { continue }
+        $ruleAssay = (Get-RowField -Row $r -FieldName 'Assay')
+        if (-not (Test-AssayMatch -RuleAssay $ruleAssay -RowAssay $assay)) { continue }
+
+        $mtype = (Get-RowField -Row $r -FieldName 'SampleIdMatchType')
+        $pat   = (Get-RowField -Row $r -FieldName 'SampleIdPattern')
+        if (-not ($pat + '').Trim()) { continue }
+
+        if (Match-Text -Text $sid -Pattern $pat -MatchType $mtype) {
+            $call = ((Get-RowField -Row $r -FieldName 'Expected') + '').Trim().ToUpperInvariant()
+            if ($call) {
+                $note = (Get-RowField -Row $r -FieldName 'Note')
+                $why = if (($note + '').Trim()) { $note } else { ("Matched " + $mtype + ": " + $pat) }
+                return [pscustomobject]@{ Call=$call; Reason=$why }
+            }
+        }
+    }
+
+    return [pscustomobject]@{ Call=''; Reason='No expectation rule matched' }
+}
+
+function Get-ExpectedTestTypeDerived {
+    param([Parameter(Mandatory)][string]$SampleId)
+
+    $parts = $SampleId.Split('_')
+    if ($parts.Count -ge 3) {
+        $tc = $parts[2]
+        switch -Regex ($tc) {
+            '^0$' { return 'Negative Control 1' }
+            '^1$' { return 'Positive Control 1' }
+            '^2$' { return 'Positive Control 2' }
+            '^3$' { return 'Positive Control 3' }
+            '^4$' { return 'Positive Control 4' }
+            '^5$' { return 'Positive Control 5' }
+            default { }
+        }
+    }
+    return 'Specimen'
+}
+
+function Build-ErrorCodeLookup {
+    param([Parameter(Mandatory)][object[]]$ErrorCodes)
+
+    # Supports:
+    # - numeric codes (4-5 digits)
+    # - multiple defaults via '####' (we choose based on content when possible)
+    # - "blank code" rows (used for derived flags like pressure) exposed as NamedBlanks
+    $lut = @{
+        Codes = @{}
+        Defaults = New-Object System.Collections.Generic.List[object]
+        NamedBlanks = New-Object System.Collections.Generic.List[object]
+    }
+
+    foreach ($r in $ErrorCodes) {
+        $code = ((Get-RowField -Row $r -FieldName 'ErrorCode') + '').Trim()
+        $name = (Get-RowField -Row $r -FieldName 'Name')
+        $ret  = (Get-RowField -Row $r -FieldName 'GeneratesRetest')
+
+        if ($code -eq '####') {
+            $lut.Defaults.Add([pscustomobject]@{ ErrorCode='####'; Name=$name; GeneratesRetest=$ret })
+            continue
+        }
+
+        if (-not $code) {
+            if (($name + '').Trim()) { $lut.NamedBlanks.Add([pscustomobject]@{ ErrorCode=''; Name=$name; GeneratesRetest=$ret }) }
+            continue
+        }
+
+        if ($code -match '^\d{4,5}$') {
+            $lut.Codes[$code] = [pscustomobject]@{ ErrorCode=$code; Name=$name; GeneratesRetest=$ret }
+        }
+    }
+
+    return $lut
+}
+
+function Get-ErrorInfo {
+    param(
+        [Parameter(Mandatory)][object]$Row,
+        [Parameter(Mandatory)][hashtable]$ErrorLut,
+        [Parameter(Mandatory)][string]$DelamPattern
+    )
+
+    $errTxt = (Get-RowField -Row $Row -FieldName 'Error')
+    $mpTxt  = (Get-RowField -Row $Row -FieldName 'Max Pressure (PSI)')
+
+    $code = ''
+    $hasErr = (($errTxt + '').Trim().Length -gt 0)
+
+    if ($hasErr) {
+        if (($errTxt + '') -match '(\d{4,5})') { $code = $Matches[1] }
+    }
+
+    $name = ''
+    $retest = ''
+
+    if ($hasErr) {
+        if ($code -and $ErrorLut.Codes.ContainsKey($code)) {
+            $name   = $ErrorLut.Codes[$code].Name
+            $retest = $ErrorLut.Codes[$code].GeneratesRetest
+        } else {
+            # Choose default:
+            # 1) if error text indicates delamination and a "Delamination" default exists -> use that
+            # 2) else use the last default (typically "Other error codes")
+            $picked = $null
+            try {
+                foreach ($d in $ErrorLut.Defaults) {
+                    if (($d.Name + '') -match '(?i)Delamination' -and ($errTxt + '') -match $DelamPattern) {
+                        $picked = $d; break
+                    }
+                }
+                if (-not $picked -and $ErrorLut.Defaults.Count -gt 0) { $picked = $ErrorLut.Defaults[$ErrorLut.Defaults.Count - 1] }
+            } catch {}
+            if ($picked) {
+                $name   = $picked.Name
+                $retest = $picked.GeneratesRetest
+            }
+        }
+    }
+
+    $pressure = $null
+    try {
+        if (($mpTxt + '').Trim()) { $pressure = [double]($mpTxt + '') }
+    } catch {}
+
+    $pressureFlag = $false
+    if ($pressure -ne $null -and $pressure -gt 90) { $pressureFlag = $true }
+
+    # If pressure flag and there is a named blank describing it, surface the name
+    if ($pressureFlag -and -not $name) {
+        try {
+            foreach ($b in $ErrorLut.NamedBlanks) {
+                if (($b.Name + '') -match '(?i)Max\s+Pressure') {
+                    $name = $b.Name
+                    $retest = $b.GeneratesRetest
+                    break
+                }
+            }
+        } catch {}
+    }
+
+    return [pscustomobject]@{
+        ErrorCode       = $code
+        ErrorName       = $name
+        GeneratesRetest = $retest
+        MaxPressure     = $pressure
+        PressureFlag    = $pressureFlag
+    }
+}
+
+function Classify-Deviation {
+    param(
+        [AllowEmptyString()][string]$Expected,
+        [AllowEmptyString()][string]$Observed
+    )
+    $e = ($Expected + '').Trim().ToUpperInvariant()
+    $o = ($Observed + '').Trim().ToUpperInvariant()
+
+    if (-not $e) { return 'UNKNOWN' }
+    if ($o -eq 'ERROR') { return 'ERROR' }
+    if ($o -eq 'UNKNOWN' -or -not $o) { return 'UNKNOWN' }
+    if ($e -eq $o) { return 'OK' }
+    if ($e -eq 'POS' -and $o -eq 'NEG') { return 'FN' }
+    if ($e -eq 'NEG' -and $o -eq 'POS') { return 'FP' }
+    return 'MISMATCH'
+}
+
+function Split-CsvLineQuoted {
+    param(
+        [Parameter(Mandatory)][string]$Line,
+        [Parameter(Mandatory)][string]$Delimiter
+    )
+    $d = [regex]::Escape($Delimiter)
+    $rx = $d + '(?=(?:(?:[^"]*"){2})*[^"]*$)'
+    return [regex]::Split($Line, $rx)
+}
+
+function Get-HeaderFromTestSummaryFile {
+    param([Parameter(Mandatory)][string]$CsvPath)
+
+    if (-not (Test-Path -LiteralPath $CsvPath)) { return @() }
+
+    $delim = ','
+    try { $delim = Get-CsvDelimiter -Path $CsvPath } catch {}
+
+    $lines = @()
+    try { $lines = Get-Content -LiteralPath $CsvPath -ErrorAction Stop } catch { return @() }
+
+    # Test Summary: header is line 8 (index 7)
+    if (-not $lines -or $lines.Count -lt 8) { return @() }
+    $hdrLine = $lines[7]
+    if (-not $hdrLine) { return @() }
+
+    $headers = Split-CsvLineQuoted -Line $hdrLine -Delimiter $delim
+    $headers = @($headers | ForEach-Object { (($_ + '') -replace '^"|"$','').Trim() })
+    return $headers
+}
+
+function Convert-FieldRowsToObjects {
+    param(
+        [Parameter(Mandatory)][object[]]$FieldRows,
+        [Parameter(Mandatory)][string[]]$Headers
+    )
+
+    $out = New-Object System.Collections.Generic.List[object]
+
+    foreach ($r in $FieldRows) {
+        if ($null -eq $r) { continue }
+        $arr = $r
+        if ($arr -isnot [object[]]) { continue }
+
+        $o = [ordered]@{}
+        $max = [Math]::Min($Headers.Count, $arr.Count)
+        for ($i=0; $i -lt $max; $i++) {
+            $h = $Headers[$i]
+            if (-not $h) { continue }
+            $o[$h] = $arr[$i]
+        }
+        $out.Add([pscustomobject]$o)
+    }
+
+    return $out.ToArray()
+}
+
+function Get-MarkerValue {
+    <#
+      05_SampleIdMarkers.csv schema:
+        AssayPattern,MarkerType,Marker,SampleTokenIndex,Enabled,Note
+      Returns the first enabled marker matching assay pattern + marker type (by RuleBank ordering / priority).
+    #>
+    param(
+        [Parameter(Mandatory)][pscustomobject]$RuleBank,
+        [Parameter(Mandatory)][string]$Assay,
+        [Parameter(Mandatory)][string]$MarkerType
+    )
+
+    foreach ($r in $RuleBank.SampleIdMarkers) {
+        if (-not (Test-RuleEnabled $r)) { continue }
+
+        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
+        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
+
+        $mt = ((Get-RowField -Row $r -FieldName 'MarkerType') + '').Trim()
+        if (-not $mt) { continue }
+        if ($mt -ine $MarkerType) { continue }
+
+        $m = ((Get-RowField -Row $r -FieldName 'Marker') + '').Trim()
+        return $m
+    }
+
+    return ''
+}
+
+function Get-IntMarkerValue {
+    param(
+        [Parameter(Mandatory)][pscustomobject]$RuleBank,
+        [Parameter(Mandatory)][string]$Assay,
+        [Parameter(Mandatory)][string]$MarkerType,
+        [Parameter(Mandatory)][int]$Default
+    )
+    $v = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType $MarkerType
+    if (-not $v) { return $Default }
+    try { return [int]$v } catch { return $Default }
+}
+
+function Get-ParityConfigForAssay {
+    <#
+      06_ParityCheckConfig.csv schema:
+        AssayPattern,Enabled,CartridgeField,SampleTokenIndex,SuffixX,SuffixPlus,DelaminationMarkerType,MinValidCartridgeSNPercent,Note,Priority
+    #>
+    param(
+        [Parameter(Mandatory)][pscustomobject]$RuleBank,
+        [Parameter(Mandatory)][string]$Assay
+    )
+
+    $cfg = [ordered]@{
+        UseParity = $false
+        CartridgeField = 'Cartridge S/N'
+        TokenIndex = 3
+        XChar = 'X'
+        PlusChar = '+'
+        NumericRatioThreshold = 0.60
+        DelaminationMarkerType = 'DelaminationCodeRegex'
+        DelamRegex = 'D\d{1,2}[A-Z]?'
+        ValidSuffixRegex = 'X|\+'
+        SampleTypeCodeTokenIndex = 2
+        SampleNumberTokenIndex = 3
+    }
+
+    # Pull defaults from markers (assay-aware)
+    $delam = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'DelaminationCodeRegex'
+    if ($delam) { $cfg.DelamRegex = $delam }
+
+    $suffix = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SuffixChars'
+    if ($suffix) {
+        # Some CSV exports double-escape backslashes (e.g. X|\+). Normalize "\" -> "\" for regex use.
+        while ($suffix -like '*\\*') { $suffix = $suffix.Replace('\\','\') }
+        $cfg.ValidSuffixRegex = $suffix
+    }
+
+    $stIdx = Get-IntMarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SampleTypeCodeTokenIndex' -Default 2
+    $snIdx = Get-IntMarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType 'SampleNumberTokenIndex' -Default 3
+    $cfg.SampleTypeCodeTokenIndex = $stIdx
+    $cfg.SampleNumberTokenIndex = $snIdx
+
+    foreach ($r in $RuleBank.ParityCheckConfig) {
+        if (-not (Test-RuleEnabled $r)) { continue }
+
+        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
+        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
+
+        # First match wins since RuleBank.ParityCheckConfig is priority-sorted DESC.
+        $cfg.UseParity = $true
+
+        $cf = ((Get-RowField -Row $r -FieldName 'CartridgeField') + '').Trim()
+        if ($cf) { $cfg.CartridgeField = $cf }
+
+        $ti = ((Get-RowField -Row $r -FieldName 'SampleTokenIndex') + '').Trim()
+        if ($ti) { try { $cfg.TokenIndex = [int]$ti } catch {} }
+
+        $sx = ((Get-RowField -Row $r -FieldName 'SuffixX') + '').Trim()
+        if ($sx) { $cfg.XChar = $sx.Substring(0,1).ToUpperInvariant() }
+
+        $sp = ((Get-RowField -Row $r -FieldName 'SuffixPlus') + '').Trim()
+        if ($sp) { $cfg.PlusChar = $sp.Substring(0,1) }
+
+        $dmt = ((Get-RowField -Row $r -FieldName 'DelaminationMarkerType') + '').Trim()
+        if ($dmt) { $cfg.DelaminationMarkerType = $dmt }
+
+        $minPct = ((Get-RowField -Row $r -FieldName 'MinValidCartridgeSNPercent') + '').Trim()
+        if ($minPct) {
+            try { $cfg.NumericRatioThreshold = ([double]$minPct) / 100.0 } catch {}
+        }
+
+        break
+    }
+
+    # Refresh delam regex by configured marker type
+    if ($cfg.DelaminationMarkerType) {
+        $delam2 = Get-MarkerValue -RuleBank $RuleBank -Assay $Assay -MarkerType $cfg.DelaminationMarkerType
+        if ($delam2) { $cfg.DelamRegex = $delam2 }
+    }
+
+    return [pscustomobject]$cfg
+}
+
+function Get-ControlCodeFromRow {
+    param(
+        [Parameter(Mandatory)][object]$Row,
+        [Parameter(Mandatory)][int]$SampleTypeCodeTokenIndex
+    )
+
+    $sid = (Get-RowField -Row $Row -FieldName 'Sample ID')
+    if (($sid + '').Trim()) {
+        $parts = ($sid + '').Split('_')
+        if ($parts.Count -gt $SampleTypeCodeTokenIndex) {
+            $cc = ($parts[$SampleTypeCodeTokenIndex] + '').Trim()
+            if ($cc -match '^\d+$') { return $cc }
+        }
+        # Legacy: token2 is commonly sample type code
+        if ($parts.Count -ge 3) {
+            $cc2 = ($parts[2] + '').Trim()
+            if ($cc2 -match '^\d+$') { return $cc2 }
+        }
+    }
+
+    $tt = (Get-RowField -Row $Row -FieldName 'Test Type')
+    if (($tt + '') -match '(?i)Negative\s+Control') { return '0' }
+    if (($tt + '') -match '(?i)Positive\s+Control\s+(\d+)') { return $Matches[1] }
+
+    return ''
+}
+
+function Get-SampleTokenAndBase {
+    param(
+        [Parameter(Mandatory)][string]$SampleId,
+        [Parameter(Mandatory)][int]$TokenIndex,
+        [Parameter(Mandatory)][string]$DelamPattern,
+        [Parameter(Mandatory)][string]$ValidSuffixRegex,
+        [Parameter(Mandatory)][string]$XChar,
+        [Parameter(Mandatory)][string]$PlusChar
+    )
+
+    $tok = ''
+    $base = ''
+
+    $parts = $SampleId.Split('_')
+    if ($parts.Count -gt $TokenIndex) {
+        $tok = ($parts[$TokenIndex] + '').Trim()
+    }
+
+    if (-not $tok) { return [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw=''; } }
+
+    # strip trailing delamination code if present INSIDE token
+    $rx = "([_-]?(?:" + $DelamPattern + "))$"
+    try {
+        $base = [regex]::Replace($tok, $rx, '', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
+    } catch {
+        $base = $tok
+    }
+
+    $base = ($base + '').Trim()
+
+    $act = ''
+    if ($base.Length -ge 1) {
+        $last = $base.Substring($base.Length - 1, 1)
+        if ($last -match ('^(?:' + $ValidSuffixRegex + ')$')) {
+            $u = $last.ToUpperInvariant()
+            if ($u -eq $XChar.ToUpperInvariant()) { $act = $XChar.ToUpperInvariant() }
+            elseif ($last -eq $PlusChar) { $act = $PlusChar }
+            else { $act = $u }
+        }
+    }
+
+    $numRaw = ''
+    $num = ''
+    if ($base -match '^(\d{1,4})') {
+        $numRaw = $Matches[1]
+        $num = $numRaw
+    }
+
+    return [pscustomobject]@{ SampleToken=$tok; BaseToken=$base; ActualSuffix=$act; SampleNum=$num; SampleNumRaw=$numRaw }
+}
+
+function Get-SampleNumberRuleForRow {
+    <#
+      07_SampleNumberRules.csv schema:
+        AssayPattern,SampleTypeCode,SampleNumberTokenIndex,SampleNumberRegex,SampleNumberMin,SampleNumberMax,SampleNumberPad,Enabled,Note,Priority
+    #>
+    param(
+        [Parameter(Mandatory)][string]$Assay,
+        [Parameter(Mandatory)][string]$ControlCode,
+        [Parameter(Mandatory)][object[]]$Rules
+    )
+
+    foreach ($r in $Rules) {
+        if (-not (Test-RuleEnabled $r)) { continue }
+
+        $ap = ((Get-RowField -Row $r -FieldName 'AssayPattern') + '').Trim()
+        if (-not (Test-AssayMatch -RuleAssay $ap -RowAssay $Assay)) { continue }
+
+        $cc = ((Get-RowField -Row $r -FieldName 'SampleTypeCode') + '').Trim()
+        if (-not $cc -or $cc -eq '*') { return $r }
+        if ($ControlCode -and ($cc -eq $ControlCode)) { return $r }
+    }
+
+    return $null
+}
+
+function Invoke-RuleEngine {
+    param(
+        [Parameter(Mandatory=$true)][AllowEmptyCollection()][object[]]$CsvObjects,
+        [Parameter(Mandatory)][pscustomobject]$RuleBank,
+        [Parameter(Mandatory=$false)][string]$CsvPath
+    )
+
+    if (-not $CsvObjects -or $CsvObjects.Count -eq 0) {
+        return [pscustomobject]@{ Rows=@(); Summary=[pscustomobject]@{ Total=0; ObservedCounts=@{}; DeviationCounts=@{}; RetestYes=0 }; TopDeviations=@() }
+    }
+
+    # Convert field-arrays (from Import-CsvRows) to objects using header from file
+    $needsConvert = $false
+    try {
+        if ($CsvObjects[0] -is [object[]]) { $needsConvert = $true }
+        else {
+            $p1 = $CsvObjects[0].PSObject.Properties.Match('Sample ID')
+            if ($p1.Count -eq 0) { $needsConvert = $true }
+        }
+    } catch { $needsConvert = $true }
+
+    if ($needsConvert) {
+        if (-not $CsvPath) { throw 'RuleEngine: CsvPath is required to convert field-array rows to objects.' }
+        $hdr = Get-HeaderFromTestSummaryFile -CsvPath $CsvPath
+        if (-not $hdr -or $hdr.Count -lt 5) { throw 'RuleEngine: Could not read CSV header (line 8).' }
+        $CsvObjects = Convert-FieldRowsToObjects -FieldRows $CsvObjects -Headers $hdr
+        if (-not $CsvObjects -or $CsvObjects.Count -eq 0) {
+            return [pscustomobject]@{ Rows=@(); Summary=[pscustomobject]@{ Total=0; ObservedCounts=@{}; DeviationCounts=@{}; RetestYes=0 }; TopDeviations=@() }
+        }
+    }
+
+    # Group by assay: parity + suffix expectations are assay-configurable.
+    $byAssay = @{}
+    foreach ($row in $CsvObjects) {
+        $a = (Get-RowField -Row $row -FieldName 'Assay')
+        $key = (($a + '').Trim())
+        if (-not $key) { $key = '(blank)' }
+        if (-not $byAssay.ContainsKey($key)) { $byAssay[$key] = New-Object System.Collections.Generic.List[object] }
+        $byAssay[$key].Add($row)
+    }
+
+    $results = New-Object System.Collections.Generic.List[object]
+    $errLut = Build-ErrorCodeLookup -ErrorCodes $RuleBank.ErrorCodes
+
+    foreach ($assayKey in $byAssay.Keys) {
+        $group = $byAssay[$assayKey]
+        if (-not $group -or $group.Count -eq 0) { continue }
+
+        $parCfg = Get-ParityConfigForAssay -RuleBank $RuleBank -Assay $assayKey
+        $delamPattern = $parCfg.DelamRegex
+        $validSuffix = $parCfg.ValidSuffixRegex
+
+        # Pre-scan for parity + majority suffix
+        $numeric = New-Object System.Collections.Generic.List[long]
+        $suffixCounts = @{}
+        $suffixCounts[$parCfg.XChar.ToUpperInvariant()] = 0
+        $suffixCounts[$parCfg.PlusChar] = 0
+
+        foreach ($row in $group) {
+            $sn = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
+            if (($sn + '').Trim() -match '^\d+$') {
+                try { $numeric.Add([long]($sn + '')) } catch {}
+            }
+
+            $sid = (Get-RowField -Row $row -FieldName 'Sample ID')
+            if (($sid + '').Trim()) {
+                $t = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $parCfg.TokenIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
+                if ($t.ActualSuffix -and $suffixCounts.ContainsKey($t.ActualSuffix)) { $suffixCounts[$t.ActualSuffix]++ }
+            }
+        }
+
+        $numRatio = 0.0
+        try { $numRatio = [double]$numeric.Count / [double]$group.Count } catch {}
+
+        $useParity = ($parCfg.UseParity -and $numeric.Count -gt 0 -and $numRatio -ge $parCfg.NumericRatioThreshold)
+
+        $minSn = $null
+        $parityForX = $null
+        if ($useParity) {
+            try {
+                $minSn = ($numeric | Measure-Object -Minimum).Minimum
+                $parityForX = [int]($minSn % 2)
+            } catch {
+                $useParity = $false
+            }
+        }
+
+        $majSuffix = ''
+        if (-not $useParity) {
+            $xCount = $suffixCounts[$parCfg.XChar.ToUpperInvariant()]
+            $pCount = $suffixCounts[$parCfg.PlusChar]
+            if ($xCount -gt $pCount) { $majSuffix = $parCfg.XChar.ToUpperInvariant() }
+            elseif ($pCount -gt $xCount) { $majSuffix = $parCfg.PlusChar }
+        }
+
+        foreach ($row in $group) {
+            try {
+                $obsD = Get-ObservedCallDetailed -Row $row -Patterns $RuleBank.ResultCallPatterns -AssayObservedCallRules $RuleBank.AssayObservedCallRules
+                $expD = Get-ExpectedCallDetailed -Row $row -Rules $RuleBank.SampleExpectationRules
+
+                $sid = (Get-RowField -Row $row -FieldName 'Sample ID')
+                $assay = (Get-RowField -Row $row -FieldName 'Assay')
+
+                $expTT = ''
+                if (($sid + '').Trim()) { $expTT = Get-ExpectedTestTypeDerived -SampleId ($sid + '') }
+
+                # ExpectedCall fallback: derive from Test Type / control code when no explicit rule matched
+                $expCall = ($expD.Call + '').Trim().ToUpperInvariant()
+                $expSrc = 'RULE'
+                if (-not $expCall) {
+                    $tt = (Get-RowField -Row $row -FieldName 'Test Type')
+                    $tt2 = ($tt + '')
+                    if ($tt2 -match '(?i)Negative\s+Control') { $expCall = 'NEG'; $expSrc = 'TESTTYPE' }
+                    elseif ($tt2 -match '(?i)Positive\s+Control') { $expCall = 'POS'; $expSrc = 'TESTTYPE' }
+                    else {
+                        $cc2 = Get-ControlCodeFromRow -Row $row -SampleTypeCodeTokenIndex $parCfg.SampleTypeCodeTokenIndex
+                        if ($cc2 -match '^\d+$') {
+                            if ([int]$cc2 -eq 0) { $expCall = 'NEG'; $expSrc = 'CONTROL_CODE' }
+                            elseif ([int]$cc2 -ge 1) { $expCall = 'POS'; $expSrc = 'CONTROL_CODE' }
+                        }
+                    }
+                }
+
+                $errInfo = Get-ErrorInfo -Row $row -ErrorLut $errLut -DelamPattern $delamPattern
+                $dev = Classify-Deviation -Expected $expCall -Observed $obsD.Call
+
+                # Suffix / parity validation (naming robustness)
+                $tokInfo = [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw='' }
+                if (($sid + '').Trim()) {
+                    $tokInfo = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $parCfg.TokenIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
+                }
+
+                $expectedSuffix = ''
+                $suffixSource = ''
+                $suffixCheck = ''
+
+                $snVal = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
+                $snNum = $null
+                if (($snVal + '').Trim() -match '^\d+$') { try { $snNum = [long]($snVal + '') } catch {} }
+
+                if ($tokInfo.ActualSuffix) {
+                    if ($useParity -and $snNum -ne $null -and $parityForX -ne $null) {
+                        $expS = if (([int]($snNum % 2)) -eq $parityForX) { $parCfg.XChar.ToUpperInvariant() } else { $parCfg.PlusChar }
+                        $expectedSuffix = $expS
+                        $suffixSource = 'PARITY'
+                    } elseif ($majSuffix) {
+                        $expectedSuffix = $majSuffix
+                        $suffixSource = 'MAJORITY'
+                    }
+
+                    if ($expectedSuffix) {
+                        $suffixCheck = if ($tokInfo.ActualSuffix -eq $expectedSuffix) { 'OK' } else { 'BAD' }
+                    }
+                }
+
+                # Sample number validation (config-driven)
+                $sampleNum = ''
+                $sampleNumRaw = ''
+                $sampleNumOk = ''
+                $sampleNumWhy = ''
+
+                $cc = Get-ControlCodeFromRow -Row $row -SampleTypeCodeTokenIndex $parCfg.SampleTypeCodeTokenIndex
+
+                $rule = $null
+                try { $rule = Get-SampleNumberRuleForRow -Assay $assay -ControlCode $cc -Rules $RuleBank.SampleNumberRules } catch {}
+
+                $snTokIndex = $parCfg.SampleNumberTokenIndex
+                if ($rule) {
+                    $idxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberTokenIndex') + '').Trim()
+                    if ($idxTxt) { try { $snTokIndex = [int]$idxTxt } catch {} }
+                }
+
+                $snInfo = [pscustomobject]@{ SampleToken=''; BaseToken=''; ActualSuffix=''; SampleNum=''; SampleNumRaw='' }
+                if (($sid + '').Trim()) {
+                    $snInfo = Get-SampleTokenAndBase -SampleId ($sid + '') -TokenIndex $snTokIndex -DelamPattern $delamPattern -ValidSuffixRegex $validSuffix -XChar $parCfg.XChar -PlusChar $parCfg.PlusChar
+                }
+                $sampleNum = $snInfo.SampleNum
+                $sampleNumRaw = $snInfo.SampleNumRaw
+
+                if ($rule) {
+                    $rxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberRegex') + '').Trim()
+                    $minTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberMin') + '').Trim()
+                    $maxTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberMax') + '').Trim()
+                    $padTxt = ((Get-RowField -Row $rule -FieldName 'SampleNumberPad') + '').Trim()
+
+                    $min = 0; $max = 0; $pad = 0
+                    try { $min = [int]$minTxt } catch {}
+                    try { $max = [int]$maxTxt } catch {}
+                    try { $pad = [int]$padTxt } catch {}
+
+                    if (-not $sampleNum) {
+                        $sampleNumOk = 'NO'
+                        $sampleNumWhy = 'No sample number'
+                    } else {
+                        $numInt = 0
+                        try { $numInt = [int]$sampleNum } catch { $numInt = 0 }
+
+                        $rxOk = $true
+                        if ($rxTxt) {
+                            try { $rxOk = [regex]::IsMatch(($snInfo.BaseToken + ''), $rxTxt, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } catch { $rxOk = $true }
+                        }
+
+                        $padOk = $true
+                        if ($pad -gt 0 -and ($sampleNumRaw + '').Length -ne $pad) { $padOk = $false }
+
+                        if ($rxOk -and $padOk -and $min -gt 0 -and $max -gt 0 -and $numInt -ge $min -and $numInt -le $max) {
+                            $sampleNumOk = 'YES'
+                        } else {
+                            $sampleNumOk = 'NO'
+                            $sampleNumWhy = 'Out of range/regex/pad'
+                        }
+                    }
+                }
+
+                $results.Add([pscustomobject]@{
+                    SampleId         = $sid
+                    CartridgeSN      = (Get-RowField -Row $row -FieldName $parCfg.CartridgeField)
+                    Assay            = $assay
+                    AssayVersion     = (Get-RowField -Row $row -FieldName 'Assay Version')
+                    ReagentLotId     = (Get-RowField -Row $row -FieldName 'Reagent Lot ID')
+                    TestType         = (Get-RowField -Row $row -FieldName 'Test Type')
+                    ExpectedTestType = $expTT
+                    ControlCode      = $cc
+                    SampleToken      = $tokInfo.SampleToken
+                    BaseToken        = $tokInfo.BaseToken
+                    ActualSuffix     = $tokInfo.ActualSuffix
+                    ExpectedSuffix   = $expectedSuffix
+                    SuffixCheck      = $suffixCheck
+                    SuffixSource     = $suffixSource
+                    SampleNum        = $sampleNum
+                    SampleNumOK      = $sampleNumOk
+                    SampleNumWhy     = $sampleNumWhy
+                    Status           = (Get-RowField -Row $row -FieldName 'Status')
+                    TestResult       = (Get-RowField -Row $row -FieldName 'Test Result')
+                    ErrorText        = (Get-RowField -Row $row -FieldName 'Error')
+                    MaxPressure      = $errInfo.MaxPressure
+                    PressureFlag     = $errInfo.PressureFlag
+                    ErrorCode        = $errInfo.ErrorCode
+                    ErrorName        = $errInfo.ErrorName
+                    GeneratesRetest  = $errInfo.GeneratesRetest
+                    ObservedCall     = $obsD.Call
+                    ObservedWhy      = $obsD.Reason
+                    ExpectedCall     = $expCall
+                    ExpectedWhy      = $expD.Reason
+                    ExpectedSource   = $expSrc
+                    Deviation        = $dev
+                    ModuleSN         = (Get-RowField -Row $row -FieldName 'Module S/N')
+                    StartTime        = (Get-RowField -Row $row -FieldName 'Start Time')
+                    RuleFlags        = ''
+                })
+
+            } catch {
+                $sid2 = ''
+                try { $sid2 = (Get-RowField -Row $row -FieldName 'Sample ID') } catch {}
+                throw ("RuleEngine row-fel (Sample ID=" + $sid2 + "): " + $_.Exception.Message)
+            }
+        }
+    }
+
+
+
+    # --- QC post-processing (file-level validations + per-row flags) ---
+    function _Append-RuleFlag {
+        param([pscustomobject]$row, [string]$flag)
+        $f = (($row.RuleFlags + '')).Trim()
+        if (-not $f) { $row.RuleFlags = $flag; return }
+        $parts = $f.Split('|')
+        if ($parts -contains $flag) { return }
+        $row.RuleFlags = ($f + '|' + $flag)
+    }
+
+    # Distinct counts (file-level)
+    $distinctAssays = @($results | ForEach-Object { ($_.Assay + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
+    $distinctAssayVersions = @($results | ForEach-Object { ($_.AssayVersion + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
+    $distinctReagentLots = @($results | ForEach-Object { ($_.ReagentLotId + '').Trim() } | Where-Object { $_ } | Sort-Object -Unique)
+
+    # Duplicate Sample IDs
+    $dupSample = @($results | Where-Object { (($_.SampleId + '').Trim()) } | Group-Object SampleId | Where-Object { $_.Count -gt 1 })
+    if ($dupSample.Count -gt 0) {
+        $dupSet = @{}
+        foreach ($g in $dupSample) { $dupSet[$g.Name] = $true }
+        foreach ($r in $results) {
+            $sid = ((($r.SampleId + '')).Trim())
+            if ($sid -and $dupSet.ContainsKey($sid)) { _Append-RuleFlag -row $r -flag 'DQ_DUP_SAMPLEID' }
+        }
+    }
+
+    # Duplicate Cartridge S/N
+    $dupCart = @($results | Where-Object { (($_.CartridgeSN + '').Trim()) } | Group-Object CartridgeSN | Where-Object { $_.Count -gt 1 })
+    if ($dupCart.Count -gt 0) {
+        $dupSet = @{}
+        foreach ($g in $dupCart) { $dupSet[$g.Name] = $true }
+        foreach ($r in $results) {
+            $csn = ((($r.CartridgeSN + '')).Trim())
+            if ($csn -and $dupSet.ContainsKey($csn)) { _Append-RuleFlag -row $r -flag 'DQ_DUP_CARTSN' }
+        }
+    }
+
+    # Test Type mismatch (derived expected vs actual)
+    foreach ($r in $results) {
+        $act = ((($r.TestType + '')).Trim())
+        $exp = ((($r.ExpectedTestType + '')).Trim())
+        if ($act -and $exp -and ($act.ToUpperInvariant() -ne $exp.ToUpperInvariant())) {
+            _Append-RuleFlag -row $r -flag 'TESTTYPE_MISMATCH'
+        }
+    }
+
+    # Module hotspot: >=3 ERROR rows on same Module S/N
+    $hotModules = @{}
+    $byModErr = @($results | Where-Object { (($_.ModuleSN + '').Trim()) -and (($_.ObservedCall + '').Trim().ToUpperInvariant() -eq 'ERROR') } | Group-Object ModuleSN)
+    foreach ($g in $byModErr) {
+        if ($g.Count -ge 3) { $hotModules[$g.Name] = $g.Count }
+    }
+    if ($hotModules.Count -gt 0) {
+        foreach ($r in $results) {
+            $m = ((($r.ModuleSN + '')).Trim())
+            if ($m -and $hotModules.ContainsKey($m)) { _Append-RuleFlag -row $r -flag 'MODULE_ERR_HOTSPOT' }
+        }
+    }
+
+    # Attach QC stats to result (used by Debug sheet summary)
+    $qc = [pscustomobject]@{
+        DistinctAssays = $distinctAssays
+        DistinctAssayVersions = $distinctAssayVersions
+        DistinctReagentLots = $distinctReagentLots
+        DuplicateSampleIdCount = ($dupSample | ForEach-Object { $_.Name } | Select-Object -Unique).Count
+        DuplicateCartridgeSnCount = ($dupCart | ForEach-Object { $_.Name } | Select-Object -Unique).Count
+        HotModuleCount = $hotModules.Count
+    }
+    # ---------------------------------------------------------------
+    $summary = [pscustomobject]@{
+        Total = $results.Count
+        ObservedCounts = @{}
+        DeviationCounts = @{}
+        RetestYes = 0
+    }
+
+    foreach ($r in $results) {
+        if (-not $summary.ObservedCounts.ContainsKey($r.ObservedCall)) { $summary.ObservedCounts[$r.ObservedCall] = 0 }
+        $summary.ObservedCounts[$r.ObservedCall]++
+
+        if (-not $summary.DeviationCounts.ContainsKey($r.Deviation)) { $summary.DeviationCounts[$r.Deviation] = 0 }
+        $summary.DeviationCounts[$r.Deviation]++
+
+        $rt = ($r.GeneratesRetest + '').Trim().ToUpperInvariant()
+        if ($rt -in @('YES','Y','TRUE','1')) { $summary.RetestYes++ }
+    }
+
+    $top = @($results | Where-Object { $_.Deviation -in @('FP','FN','ERROR','MISMATCH') } | Select-Object -First 50)
+
+    return [pscustomobject]@{ Rows = $results.ToArray(); Summary = $summary; TopDeviations = $top; QC = $qc }
+}
+
+function Write-RuleEngineDebugSheet {
+    param(
+        [Parameter(Mandatory)][object]$Pkg,
+        [Parameter(Mandatory)][pscustomobject]$RuleEngineResult,
+        [Parameter(Mandatory=$false)][bool]$IncludeAllRows = $false
+    )
+
+    try {
+        $old = $Pkg.Workbook.Worksheets['RuleEngine_Debug']
+        if ($old) { $Pkg.Workbook.Worksheets.Delete($old) }
+    } catch {}
+
+    $ws = $Pkg.Workbook.Worksheets.Add('RuleEngine_Debug')
+
+    $headers = @(
+        '#','Sample ID','Cartridge S/N','Module S/N','Start Time',
+        'Test Type','Expected Test Type','ControlCode',
+        'SampleToken','BaseToken','ActualSuffix','ExpectedSuffix','SuffixCheck','SuffixSource',
+        'SampleNum','SampleNumOK','SampleNumWhy',
+        'Expected Call','ExpectedSource','Observed Call','ObservedWhy','Deviation','RuleFlags',
+        'Status','ErrorCode','ErrorName','Retest','Max Pressure','PressureFlag',
+        'Test Result','Error'
+    )
+
+    # --- Summary section (always written, even when exception-only table has 0 rows) ---
+    $row = 1
+    $ws.Cells[$row,1].Value = 'RuleEngine Debug Summary'
+    $ws.Cells[$row,1].Style.Font.Bold = $true
+    $row++
+
+    $sum = $RuleEngineResult.Summary
+    $qc  = $RuleEngineResult.QC
+
+    function _WriteKV {
+        param([int]$r, [string]$k, $v)
+        $ws.Cells[$r,1].Value = $k
+        $ws.Cells[$r,2].Value = $v
+        $ws.Cells[$r,1].Style.Font.Bold = $true
+    }
+
+    _WriteKV -r $row -k 'Total tests' -v $sum.Total; $row++
+
+    foreach ($k in @('OK','FP','FN','ERROR','MISMATCH','UNKNOWN')) {
+        if ($sum.DeviationCounts.ContainsKey($k)) { _WriteKV -r $row -k ('Deviation ' + $k) -v $sum.DeviationCounts[$k]; $row++ }
+    }
+
+    foreach ($k in @('POS','NEG','ERROR','UNKNOWN')) {
+        if ($sum.ObservedCounts.ContainsKey($k)) { _WriteKV -r $row -k ('Observed ' + $k) -v $sum.ObservedCounts[$k]; $row++ }
+    }
+
+    _WriteKV -r $row -k 'Retest YES' -v $sum.RetestYes; $row++
+
+    if ($qc) {
+        _WriteKV -r $row -k 'Assays (distinct)' -v ($qc.DistinctAssays.Count); $row++
+        _WriteKV -r $row -k 'Assay versions (distinct)' -v ($qc.DistinctAssayVersions.Count); $row++
+        _WriteKV -r $row -k 'Reagent lots (distinct)' -v ($qc.DistinctReagentLots.Count); $row++
+        _WriteKV -r $row -k 'Duplicate Sample IDs' -v $qc.DuplicateSampleIdCount; $row++
+        _WriteKV -r $row -k 'Duplicate Cartridge S/N' -v $qc.DuplicateCartridgeSnCount; $row++
+        _WriteKV -r $row -k 'Hot modules (>=3 errors)' -v $qc.HotModuleCount; $row++
+
+        if ($qc.DistinctAssays.Count -gt 1) { _WriteKV -r $row -k 'Assay list' -v ($qc.DistinctAssays -join ', '); $row++ }
+        if ($qc.DistinctAssayVersions.Count -gt 1) { _WriteKV -r $row -k 'Assay version list' -v ($qc.DistinctAssayVersions -join ', '); $row++ }
+        if ($qc.DistinctReagentLots.Count -gt 1) { _WriteKV -r $row -k 'Reagent lot list' -v ($qc.DistinctReagentLots -join ', '); $row++ }
+    }
+
+    $row++
+    $tableHeaderRow = $row
+
+    for ($c = 1; $c -le $headers.Count; $c++) {
+        $ws.Cells[$tableHeaderRow,$c].Value = $headers[$c-1]
+        $ws.Cells[$tableHeaderRow,$c].Style.Font.Bold = $true
+    }
+
+    $rows = $RuleEngineResult.Rows
+
+    # --- Exception-based filter (does NOT modify RuleEngineResult) ---
+    $rowsToWrite = $rows
+    if (-not $IncludeAllRows) {
+        $rowsToWrite = @($rows | Where-Object {
+            $dev = (($_.Deviation + '')).Trim().ToUpperInvariant()
+            $hasDeviation = ($dev.Length -gt 0 -and $dev -ne 'OK')
+
+            $obs = (($_.ObservedCall + '')).Trim().ToUpperInvariant()
+            $observedErr = ($obs -eq 'ERROR')
+
+            $pressureFlag = $false
+            try { $pressureFlag = [bool]$_.PressureFlag } catch { $pressureFlag = $false }
+
+            $hasErrorCode = ((($_.ErrorCode + '')).Trim().Length -gt 0)
+
+            $st = (($_.Status + '')).Trim()
+            $statusNotDone = ($st.Length -gt 0 -and $st -ne 'Done')
+
+            $retestTrue = $false
+            $rt = (($_.GeneratesRetest + '')).Trim().ToUpperInvariant()
+            if ($rt -in @('YES','Y','TRUE','1')) { $retestTrue = $true }
+
+            $rf = (($_.RuleFlags + '')).Trim()
+            $hasRuleFlags = ($rf.Length -gt 0)
+
+            return ($hasDeviation -or $observedErr -or $pressureFlag -or $hasErrorCode -or $statusNotDone -or $retestTrue -or $hasRuleFlags)
+        })
+    }
+
+    if (-not $rowsToWrite -or $rowsToWrite.Count -eq 0) {
+        $ws.Cells[$tableHeaderRow+1,2].Value = 'No deviations found'
+        $ws.Cells[$tableHeaderRow+1,2].Style.Font.Italic = $true
+        try { if ($ws.Dimension) { $ws.Cells[$ws.Dimension.Address].AutoFitColumns() } } catch {}
+        return $ws
+    }
+
+    $rOut = $tableHeaderRow + 1
+    $idx = 1
+
+    foreach ($r in $rowsToWrite) {
+        $ws.Cells[$rOut,1].Value  = $idx
+        $ws.Cells[$rOut,2].Value  = ($r.SampleId + '')
+        $ws.Cells[$rOut,3].Value  = ($r.CartridgeSN + '')
+        $ws.Cells[$rOut,4].Value  = ($r.ModuleSN + '')
+        $ws.Cells[$rOut,5].Value  = ($r.StartTime + '')
+
+        $ws.Cells[$rOut,6].Value  = ($r.TestType + '')
+        $ws.Cells[$rOut,7].Value  = ($r.ExpectedTestType + '')
+        $ws.Cells[$rOut,8].Value  = ($r.ControlCode + '')
+
+        $ws.Cells[$rOut,9].Value  = ($r.SampleToken + '')
+        $ws.Cells[$rOut,10].Value = ($r.BaseToken + '')
+        $ws.Cells[$rOut,11].Value = ($r.ActualSuffix + '')
+        $ws.Cells[$rOut,12].Value = ($r.ExpectedSuffix + '')
+        $ws.Cells[$rOut,13].Value = ($r.SuffixCheck + '')
+        $ws.Cells[$rOut,14].Value = ($r.SuffixSource + '')
+
+        $ws.Cells[$rOut,15].Value = ($r.SampleNum + '')
+        $ws.Cells[$rOut,16].Value = ($r.SampleNumOK + '')
+        $ws.Cells[$rOut,17].Value = ($r.SampleNumWhy + '')
+
+        $ws.Cells[$rOut,18].Value = ($r.ExpectedCall + '')
+        $ws.Cells[$rOut,19].Value = ($r.ExpectedSource + '')
+        $ws.Cells[$rOut,20].Value = ($r.ObservedCall + '')
+        $ws.Cells[$rOut,21].Value = ($r.ObservedWhy + '')
+        $ws.Cells[$rOut,22].Value = ($r.Deviation + '')
+        $ws.Cells[$rOut,23].Value = ($r.RuleFlags + '')
+
+        $ws.Cells[$rOut,24].Value = ($r.Status + '')
+        $ws.Cells[$rOut,25].Value = ($r.ErrorCode + '')
+        $ws.Cells[$rOut,26].Value = ($r.ErrorName + '')
+        $ws.Cells[$rOut,27].Value = ($r.GeneratesRetest + '')
+        $ws.Cells[$rOut,28].Value = $(if ($null -ne $r.MaxPressure) { $r.MaxPressure } else { '' })
+        $ws.Cells[$rOut,29].Value = $(if ($r.PressureFlag) { 'YES' } else { '' })
+
+        $ws.Cells[$rOut,30].Value = ($r.TestResult + '')
+        $ws.Cells[$rOut,31].Value = ($r.ErrorText + '')
+
+        $rOut++; $idx++
+    }
+
+    try { if ($ws.Dimension) { $ws.Cells[$ws.Dimension.Address].AutoFitColumns() } } catch {}
+    return $ws
 }--- a/New folder/RuleBank/README.md
+++ b/New folder/RuleBank/README.md
@@ -1,17 +1,18 @@
-# RuleBank Configuration Guide
-
-## Filhierarki
-- 01_ResultCallPatterns.csv: Tolkar "Test Result" â Call (POS/NEG/ERROR)
-- 02_SampleExpectationRules.csv: FÃ¶rvÃ¤ntat call baserat pÃ¥ Sample ID
-- 03_ErrorCodes.csv: Felkodsmappning (inkl. intervall)
-- 04_MissingSamplesConfig.csv: Konfig fÃ¶r saknade samples (template)
-- 05_SampleIdMarkers.csv: Markers/tokenindex fÃ¶r Sample ID
-- 06_ParityCheckConfig.csv: Parity/suffix-logik per assay
-- 07_SampleNumberRules.csv: Sample-nummerregler (regex, min/max, padding)
-
-## LÃ¤gga till nytt assay (checklista)
-1. LÃ¤gg till patterns i 01_ResultCallPatterns.csv
-2. LÃ¤gg till expectations i 02_SampleExpectationRules.csv
-3. LÃ¤gg till markers i 05_SampleIdMarkers.csv (om behÃ¶vs)
-4. LÃ¤gg till parity-config i 06_ParityCheckConfig.csv (om behÃ¶vs)
-5. LÃ¤gg till sample-number-regler i 07_SampleNumberRules.csv
+ï»¿# RuleBank Configuration Guide
+
+## Filhierarki
+- 01_ResultCallPatterns.csv: Tolkar "Test Result" â Call (POS/NEG/ERROR)
+- 08_AssayObservedCallRules.csv: Assay-specifik fallback fÃ¶r ObservedCall nÃ¤r 01 inte matchar (icke-MTB).
+- 02_SampleExpectationRules.csv: FÃ¶rvÃ¤ntat call baserat pÃ¥ Sample ID
+- 03_ErrorCodes.csv: Felkodsmappning (inkl. intervall)
+- 04_MissingSamplesConfig.csv: Konfig fÃ¶r saknade samples (template)
+- 05_SampleIdMarkers.csv: Markers/tokenindex fÃ¶r Sample ID
+- 06_ParityCheckConfig.csv: Parity/suffix-logik per assay
+- 07_SampleNumberRules.csv: Sample-nummerregler (regex, min/max, padding)
+
+## LÃ¤gga till nytt assay (checklista)
+1. LÃ¤gg till patterns i 01_ResultCallPatterns.csv
+2. LÃ¤gg till expectations i 02_SampleExpectationRules.csv
+3. LÃ¤gg till markers i 05_SampleIdMarkers.csv (om behÃ¶vs)
+4. LÃ¤gg till parity-config i 06_ParityCheckConfig.csv (om behÃ¶vs)
+5. LÃ¤gg till sample-number-regler i 07_SampleNumberRules.csv--- a/New folder/RuleBank/08_AssayObservedCallRules.csv
+++ b/New folder/RuleBank/08_AssayObservedCallRules.csv
@@ -0,0 +1,75 @@
+AssayPattern,Enabled,IsMTB,PosRegex,NegRegex,ErrRegex,PosWins,Note
+CARBA-R IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+CARBA-R RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Carba-R BEU IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Carba-R BEU RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Ebola RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+GBS LB RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+GBS LB XC IUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HCV IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HCV VL WB RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HCV Viral Load RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HIV-1 Viral Load RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HIV-1 Viral Load XC IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HIV-1 Viral Load XC RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+HPV HR AND GENOTYPE RUO ASSAY,TRUE,FALSE,(^|\b)(POS)(\b|$),,(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+LCE009 Xpress SARS-CoV-2 plus,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MRSA NxG IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MRSA NxG RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MRSA-SA ETA,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Respiratory Panel IUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Respiratory Panel RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Respiratory panel,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Respiratory panel CE-IVD,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Respiratory panel UKCA-IVD,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+TAP Panel IUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+TAP Panel RUO,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+XP Flu-RSV RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert C.diff-Epi,TRUE,FALSE,(^|\b)(PRESUMPTIVE\s+POSITIVE|POSITIVE)(\b|$),(^|\b)(PRESUMPTIVE\s+NEGATIVE|NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert C.difficile BT,TRUE,FALSE,(^|\b)(POS)(\b|$),(^|\b)(NEG)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert C.difficile G3,TRUE,FALSE,(^|\b)(POSITIVE|POS)(\b|$),(^|\b)(NEGATIVE|NEG)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Carba-R,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Ebola CE-IVD,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Ebola EUA,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert GBS LB XC,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HBV Viral Load,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HCV PQC,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HCV VL Fingerstick,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HIV-1 Viral Load XC,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HPV HR,TRUE,FALSE,(^|\b)(POS)(\b|$),,(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert HPV v2 HR,TRUE,FALSE,(^|\b)(POS)(\b|$),,(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MRSA NxG,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MRSA-SA BC G3,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MRSA-SA SSTI G3,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MRSA_SA_BC,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MRSA_SA_BC_CE,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Norovirus,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert SA Nasal Complete G3,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert TAP Panel,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress CoV-2 plus,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress CoV-2 plus IVD,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress Flu-RSV,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress GBS,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress GBS RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress SARS-CoV-2,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress SARS-CoV-2 CE-IVD,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress Strep A,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert Xpress_Strep A,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert vanA vanB,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert-C. difficile G2,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert_Carba-R,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert_HCV Viral Load,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert_HIV-1 Viral Load,TRUE,FALSE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpress CoV-2 plus IUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpress CoV-2 plus RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpress Flu IPT_EAT off,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpress GBS IUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpress GBS RUO,TRUE,FALSE,(^|\b)(POSITIVE)(\b|$),(^|\b)(NEGATIVE)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MTB-RIF Ultra v2 RUO,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MTB-XDR IUO,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+MTB-XDR RUO,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MTB-RIF Assay G4,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MTB-RIF JP IVD,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MTB-RIF US IVD,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MTB-RIF Ultra,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
+Xpert MTB-XDR,FALSE,TRUE,(^|\b)(DETECTED)(\b|$),(^|\b)(NOT\s+DETECTED)(\b|$),(^|\b)(INDETERMINATE|INCONCLUSIVE|UNRESOLVED|NO\s+RESULT|CANCELLED|INVALID|ABORTED|ERROR)(\b|$),TRUE,Auto-generated from Assay-spec ExpectedResult strings; non-MTB fallback for ObservedCall when RuleBank patterns miss.
