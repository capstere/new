--- a/New folder/Modules/RuleEngine.ps1
+++ b/New folder/Modules/RuleEngine.ps1
@@ -32,6 +32,7 @@
         SampleIdMarkers = @()
         ParityCheckConfig = @()
         SampleNumberRules = @()
+        AssayObservedCallRules = @()
     }
 
     if (-not (Test-Path -LiteralPath $RuleBankDir)) { return [pscustomobject]$rb }
@@ -44,6 +45,7 @@
         SampleIdMarkers         = '05_SampleIdMarkers.csv'
         ParityCheckConfig       = '06_ParityCheckConfig.csv'
         SampleNumberRules       = '07_SampleNumberRules.csv'
+        AssayObservedCallRules  = '08_AssayObservedCallRules.csv'
     }
 
     foreach ($k in $map.Keys) {
@@ -56,6 +58,7 @@
     try { $rb.SampleExpectationRules = @($rb.SampleExpectationRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
     try { $rb.ParityCheckConfig = @($rb.ParityCheckConfig | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
     try { $rb.SampleIdMarkers = @($rb.SampleIdMarkers | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
+    try { $rb.AssayObservedCallRules = @($rb.AssayObservedCallRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
     try { $rb.SampleNumberRules = @($rb.SampleNumberRules | Sort-Object { [int]($_.Priority) } -Descending) } catch {}
 
     return [pscustomobject]$rb
@@ -82,26 +85,64 @@
     return ($s -in @('TRUE','1','YES','Y'))
 }
 
+
+function Normalize-AssayForMatch {
+    param([string]$Text)
+    $t = ($Text + '').Trim()
+    if (-not $t) { return '' }
+    # Normalize common variations: underscores vs spaces, repeated whitespace
+    $t = $t -replace '_',' '
+    $t = $t -replace '\s+',' '
+    return $t.Trim()
+}
+
 function Test-AssayMatch {
     <#
       Supports:
       - empty / '*' => match all
       - wildcard patterns (contains '*' or '?') via -like
       - otherwise case-insensitive equals
+
+      Also handles common naming variations by matching against normalized forms:
+      - underscores vs spaces
+      - repeated whitespace
     #>
     param(
         [Parameter(Mandatory)][string]$RuleAssay,
         [Parameter(Mandatory)][string]$RowAssay
     )
-    $ra = ($RuleAssay + '').Trim()
-    if (-not $ra -or $ra -eq '*') { return $true }
-
-    $row = ($RowAssay + '').Trim()
-    if ($ra -like '*[*?]*') {
-        return ($row -like $ra)
-    }
-    return ($ra -ieq $row)
-}
+
+    $ra0 = ($RuleAssay + '').Trim()
+    if (-not $ra0 -or $ra0 -eq '*') { return $true }
+
+    $row0 = ($RowAssay + '').Trim()
+
+    # Build normalized variants to tolerate underscore/space drift
+    $raN  = (Normalize-AssayForMatch -Text $ra0)
+    $rowN = (Normalize-AssayForMatch -Text $row0)
+
+    $ruleVars = @($ra0, $raN, ($ra0 -replace '\s+','_'), ($raN -replace ' ','_')) | Where-Object { ($_ + '').Trim() } | Select-Object -Unique
+    $rowVars  = @($row0, $rowN, ($row0 -replace '\s+','_'), ($rowN -replace ' ','_')) | Where-Object { ($_ + '').Trim() } | Select-Object -Unique
+
+    $hasWildcard = ($ra0 -like '*[*?]*') -or ($raN -like '*[*?]*')
+
+    if ($hasWildcard) {
+        foreach ($rv in $ruleVars) {
+            foreach ($wv in $rowVars) {
+                if ($wv -like $rv) { return $true }
+            }
+        }
+        return $false
+    }
+
+    foreach ($rv in $ruleVars) {
+        foreach ($wv in $rowVars) {
+            if ($rv -ieq $wv) { return $true }
+        }
+    }
+    return $false
+}
+
 
 function Match-Text {
     param(
@@ -143,9 +184,9 @@
 function Get-ObservedCallDetailed {
     param(
         [Parameter(Mandatory)][object]$Row,
-        [Parameter(Mandatory)][object[]]$Patterns
-    )
-
+        [Parameter(Mandatory)][object[]]$Patterns,
+        [Parameter(Mandatory=$false)][object[]]$AssayObservedCallRules = @()
+    )
     $status = (Get-RowField -Row $Row -FieldName 'Status')
     $errTxt = (Get-RowField -Row $Row -FieldName 'Error')
     $testResult = (Get-RowField -Row $Row -FieldName 'Test Result')
@@ -196,7 +237,75 @@
         }
     }
 
-    return [pscustomobject]@{ Call='UNKNOWN'; Reason='No pattern matched' }
+    
+    # --- AssayObservedCallRules fallback (wildcard-first) ---
+    # Only used when no ResultCallPatterns matched.
+    # MTB-family is intentionally excluded (handled by dedicated overrides/patterns).
+    if (($assay + '') -notmatch 'MTB' -and $AssayObservedCallRules -and $AssayObservedCallRules.Count -gt 0) {
+
+        # Pick best matching rule by Priority (desc)
+        $best = $null
+        $bestPrio = -2147483648
+
+        foreach ($rr in $AssayObservedCallRules) {
+            if (-not (Test-RuleEnabled $rr)) { continue }
+
+            $isMtbRule = (Get-RowField -Row $rr -FieldName 'IsMTB')
+            if (Test-Truthy $isMtbRule) { continue }
+
+            $assPat = (Get-RowField -Row $rr -FieldName 'AssayPattern')
+            if (-not ($assPat + '').Trim()) { continue }
+
+            if (-not (Test-AssayMatch -RuleAssay $assPat -RowAssay $assay)) { continue }
+
+            $prioTxt = (Get-RowField -Row $rr -FieldName 'Priority')
+            $prio = 0
+            try { $prio = [int]$prioTxt } catch { $prio = 0 }
+
+            if ($best -eq $null -or $prio -gt $bestPrio) {
+                $best = $rr
+                $bestPrio = $prio
+            }
+        }
+
+        if ($best -ne $null) {
+            $posRx = (Get-RowField -Row $best -FieldName 'PosRegex')
+            $negRx = (Get-RowField -Row $best -FieldName 'NegRegex')
+            $errRx = (Get-RowField -Row $best -FieldName 'ErrRegex')
+            $posWins = (Get-RowField -Row $best -FieldName 'PosWins')
+
+            # Conservative error-ish fallback
+            if (($errRx + '').Trim()) {
+                try {
+                    if ([regex]::IsMatch($tr, $errRx, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)) {
+                        return [pscustomobject]@{ Call='ERROR'; Reason='AssayRules fallback: ErrRegex' }
+                    }
+                } catch { }
+            }
+
+            $hasPos = $false
+            $hasNeg = $false
+            if (($posRx + '').Trim()) {
+                try { $hasPos = [regex]::IsMatch($tr, $posRx, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } catch { $hasPos = $false }
+            }
+            if (($negRx + '').Trim()) {
+                try { $hasNeg = [regex]::IsMatch($tr, $negRx, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) } catch { $hasNeg = $false }
+            }
+
+            if ($hasPos -or $hasNeg) {
+                # Multi-target: if both tokens appear, POS wins by default
+                $pw = Test-Truthy $posWins
+                if ($hasPos -and ($pw -or -not $hasNeg)) {
+                    return [pscustomobject]@{ Call='POS'; Reason='AssayRules fallback: PosRegex' }
+                }
+                if ($hasNeg) {
+                    return [pscustomobject]@{ Call='NEG'; Reason='AssayRules fallback: NegRegex' }
+                }
+            }
+        }
+    }
+    # ------------------------------------------------------
+return [pscustomobject]@{ Call='UNKNOWN'; Reason='No pattern matched' }
 }
 
 function Get-ExpectedCallDetailed {
@@ -757,7 +866,7 @@
 
         foreach ($row in $group) {
             try {
-                $obsD = Get-ObservedCallDetailed -Row $row -Patterns $RuleBank.ResultCallPatterns
+                $obsD = Get-ObservedCallDetailed -Row $row -Patterns $RuleBank.ResultCallPatterns -AssayObservedCallRules $RuleBank.AssayObservedCallRules
                 $expD = Get-ExpectedCallDetailed -Row $row -Rules $RuleBank.SampleExpectationRules
 
                 $sid = (Get-RowField -Row $row -FieldName 'Sample ID')

--- a/New folder/RuleBank/README.md
+++ b/New folder/RuleBank/README.md
@@ -8,10 +8,11 @@
 - 05_SampleIdMarkers.csv: Markers/tokenindex för Sample ID
 - 06_ParityCheckConfig.csv: Parity/suffix-logik per assay
 - 07_SampleNumberRules.csv: Sample-nummerregler (regex, min/max, padding)
+- 08_AssayObservedCallRules.csv: Fallback (icke-MTB) för tolkning av "Test Result" när 01 saknar match
 
 ## Lägga till nytt assay (checklista)
 1. Lägg till patterns i 01_ResultCallPatterns.csv
 2. Lägg till expectations i 02_SampleExpectationRules.csv
 3. Lägg till markers i 05_SampleIdMarkers.csv (om behövs)
 4. Lägg till parity-config i 06_ParityCheckConfig.csv (om behövs)
-5. Lägg till sample-number-regler i 07_SampleNumberRules.csv
+5. Lägg till sample-number-regler i 07_SampleNumberRules.csv
--- a/New folder/RuleBank/08_AssayObservedCallRules.csv
+++ b/New folder/RuleBank/08_AssayObservedCallRules.csv
@@ -0,0 +1,3 @@
+AssayPattern,Enabled,Priority,IsMTB,PosRegex,NegRegex,ErrRegex,PosWins,Note
+*,TRUE,1000,FALSE,(\bDETECTED\b|\bPOSITIVE\b),(\bNOT\s+DETECTED\b|\bNEGATIVE\b),(\bNO\s+RESULT\b|\bINVALID\b|\bERROR\b),TRUE,Generic non-MTB fallback when ResultCallPatterns do not match
+*MTB*,FALSE,0,TRUE,,,,,Documented MTB exclusion (handled by dedicated MTB logic)
